[ { "title": "테스트 주도 개발 패턴", "url": "/posts/post34/", "categories": "Test", "tags": "Test, Unit Test, TDD", "date": "2023-01-06 00:00:00 +0900", "snippet": "TDD (Test Driven Development)한글로 하면 테스트 주도 개발 이라는 뜻이다.보통 우리의 업무 프로세스는 개발을 하고 개발한 결과물에 관한 테스트를 진행하게된다. 유닛테스트, 통합테스트, 종단간 테스트 등.. 그런데 TDD는 개발하기 전에 실패하는 테스트를 만들고, 테스트의 오류를 해결해나가면서 성공적인 테스트를 완성하는데 중점으로 개발을 진행한다.장점 꼼꼼히 개발할 수 있다 - 테스트를 먼저 만듬으로서 빠지는 요소없이 확인하면서 개발은 진행할 수 있다. 목표가 명확하다 - 우리는 개발하다보면 길을 잃을 때가 꽤나 많다. 어떠한 기능을 개발하다가 다른 사이드 이펙트가 생겨 본래 개발목적과 다른 곳에 시간을 쓰는 경우도 있고, 내가 개발을 하다보면 지금 의미있는 코딩을 하는건가? 라는 의심이 생기는 경우가 있다. 그런면에서 TDD는 테스트로 먼저 목적을 작성하기 때문에 테스트의 초록 막대를 뜨게 만들면 되는 간단한 목표가 명확하게 있다. 의사 소통의 편리함을 가질 수 있다 - 어떠한 코드를 설명할 때 간단하게 테스트를 보여줌으로 (물론 목적이 정확히 명시되어있는 잘 짜인 테스트 코드를 한 해서) 내가 주절주절 설명할 필요없이 원하는 결과를 유추할 수 있게 할 수 있다. 두려움을 관리할 수 있다 - 우리는 개발하기 전에 많은 상상을한다. “이렇게 짜면 나중에 문제가 될텐데?” 라고 생각하는 경우나 어떤 큰 기능을 만들기 전에 의욕이 안나고 어떻게 만들어야 할지 감이 안올 때 테스트를 먼저 만들면 조금 더 작은 단위로 생각할 수 있게된다. 그래서 우리는 어려운 코드를 짤 때 상황을 제어할 수 있게된다. 리팩토링 - 테스트 코드를 수월하게 짜기 위해선 자연히 커플링이 줄어들고, 디커플링을 지향하는 코드를 작성하게 된다. 그리고 테스트 코드를 통해 어떠한 기능이 중복되는지 확인하고 추상화할 수 있어 리팩토링면에서도 장점이 있다 생각한다. 유지보수나 개선 사항에서도 장점이 있을 수 있지만… 먼저 위의 생각은 본인의 생각이며 더 많은 장점이 있을 수도있고, 위의 장점이 다른 사람에겐 다르게 적용할 수도 있다.단점 테스트 코드를 짜야된다 - 테스트 코드를 아예 안 짜봤던 사람은 처음에 테스트 코드를 어떻게 짜야할지 감이 잘 안오게 된다. 어떠한 범위부터 적어야 하는지 작은 것도 테스트가 하는게 맞는지 등 처음 시작할 때 어려움을 겪을 수 있으며, 바쁜 상황에 구현하기도 바쁜데 테스트 코드를 짜라고 하면 황당할 수 있다. 기획이 안되어 있을 때 - 정확하게 구현할 목적이 정해져 있지 않고, 상황에 따라 계속 구현이 바뀌는 경우에는 TDD를 적용하기 쉽지않다. TDD는 본인이 구현할 범위나 기능등을 어느정도 산정하고 진행해야 의미있는 TDD를 만들 수 있다. 본인이 완벽할 때 - 테스트는 본인이 만든 프로그램에 대한 의심이다. 본인이 완벽하면 굳이…? 근데 자신있게 본인이 완벽한 코딩을 한다고 말할 수 있는 사람이 있긴할까 싶다. TDD 프로세스1. 테스트 작성TDD의 모든 시작은 테스트를 작성하면서 시작하게 된다.간단한 예제로 더하기를 하는 jest를 사용한 테스트코드는 아래와 같다.test(&quot;1 plus 2&quot;, () =&amp;gt; { expect(plus(1, 2)).toBe(3);});2. 테스트 실패확인위와 같이 테스트를 작성하고 npm run test를 실행해보면 (설정이 필요하지만 이건 TDD에 대한 포스팅이니 생략하겠다.)plus가 구현된게 없으니 당연히 위와 같이 당연히 실패한다.그러면 우리가 할 일은 명확하다 plus를 구현하면 된다.3. 코드 구현 / 수정아래와 같이 코드를 작성해 준다.export function plus(addend: number, augend: number) { return addend + augend;}4. 테스트 재실행그리고 다시 테스트를 실행하면 아래와 같이 성공처리가 된다!5. 중복제거(리팩토링)이 과정을 이렇게 간단한 plus 함수가 아닌 복잡한 비즈니스 로직을 구현하다 보면 중복이 되는 경우가 많이 생기게 된다.그러면 중복을 제거하고 리팩토링을 한다." }, { "title": "2022년 회고", "url": "/posts/post33/", "categories": "회고", "tags": "2022년, 회고", "date": "2022-12-30 00:00:00 +0900", "snippet": "2022년 무슨 일이 있었나? 시간대 별 3대 470kg 달성 블로그 시작 석사 학위 취득 취직 / 전문연구요원 시작 영어 회화 공부 시작 3대 470kg 달성나는 헬스와 독서 빼고는 딱히 취미가 있진 않다.그래서 쉬는날이나 평일에 퇴근 후에도 헬스를 꾸준히 하는 편이다. 그런데 언젠가 부터 증량 욕심이 꽤나 생기면서 작년에 처음으로 프로그램을 짜서 체계적으로 진행해 보았다.진행 한 프로그램은 StrongLifts 5x5와 MadCow 5x3을 진행하면서 3대 운동 증량을 목표로 운동하게 되었다.그 결과!! 올해 첫 3대 측정에서 벤치 110kg 스쿼드 170kg 데드리프트 200kg로 3대 470을 달성하였다. 뭔가 파워리프팅 프로그램을 할 때 마다 관절이나 허리에 꽤나 무리가 가는 느낌이라 (물론 내가 자세가 안 좋을 수도 있다…) 지금은 조금 휴지기를 가지고 내년부터 다시 시작해서 3대 500을 찍어보고 보디빌딩식 운동으로 변경 해보려한다.올해는 운동을 꽤나 열심히 했던 것 같다. 나에게 자존감을 채워주고 하루의 활력을 불어넣어주는 내가 정말 좋아하는 취미다.내년도 득근 💪🏻 가즈아!불로그 시작올해 4월부터 블로그를 시작했다. 많은 개발자들이 티스토리 혹은 깃블로그로 많은 지식을 공유하는데 나는 별로 그런 활동을 하지 않은 것 같다.그래서 취직할 때 한 줄의 링크를 더할 겸 나의 지식창고 혹은 일기치럼 이런 기록을 하기 위해서 블로그를 만들게 되었다.누구나 그렇 듯이 처음에는 1~3일 간격으로 꽤나 열심히 글을 쓰다가.. 요즘은 한달에 하나 쓸까 말까한다 😅 2023년부터는 1주일에 1개의 포스팅을 목표로 블로그를 운영해볼 생각이다.(티스토리로 할 껄…)보는 분이 얼마나 계신지는 모르겠지만 앞으로도 종종 찾아와주시면 좋겠다 :)석사 학위 취득8월의 학위를 디펜스하면서 파트타임 대학원 생활을 끝냈다.솔직히 블록체인을 전공하면서 꽤나 후회 하기는 했다. 아직은 실무에서 많이 쓰이지 않고, 테스트 넷을 통해서 돈을 안 들이고 개발이 가능하긴 하지만 Contract 배포나 다른 dApp을 이용할 때 gas비용 등을 지불하면서 공부하면서 돈까지 들어야 하나;; 라는 생각이 들기도 했었다.근데 결론적으로는 뭐 새로운 기술에 대한 시각도 가지게 되었고, 여러가지 dApp을 만들어보면서 블록체인의 기술에 대한 확신과 미래에 대한 판단을 할 수 있게 되었다.그리고 파트타임이다보니 프리랜서로 근무하면서 학교 생활을 병렬로 진행하였는데 진짜 꽤나 힘들었다..항상 주말이 없는 삶과 평일 저녁에도 자유로운 시간이 거의 없어서 힘든 2년을 보냈던 것 같다.어쨌든 대학원까지 잘 끝낸 나 너무 수고했네;;전문연구요원어떻게 보면 개발을 시작하면서 부터 하려고 했던 제도인 병역특례를 석사 학위를 받고 거의 바로 시작하게 되었다.학위가 디펜스 된 시점부터 계속 구직활동을 해왔고, 수많은 코딩테스트와 면접을 본 끝에 어느정도 내가 원하던 리스트에 있던 회사에 입사를 하게 되었다.프리랜서로 오래 하다보니 면접에 대한 지식이 많지 않았고, 코딩테스트도 평소에 많이 해본 적이 없기 때문에 취직에 있어서 꽤나 어려움을 겪었다.하지만 어찌저찌 최종 면접까지 간 곳이 꽤 되었고, 내가 이때까지 해왔던 도메인과는 다르지만 좋은 상사, 동료 분들과 함께 성장할 수 있는 회사에 입사하게 되어서 다행이라고 생각한다.전문연구요원의 특성 상 중간에 다른 회사로 이직하는 경우가 많지 않은데 이곳이라면 3년은 충분히 즐겁고, 개발자로서의 성장도 이루어낼 수 있는 시간이 될거라고 생각이 된다.영어 회화 공부영어 회화 학원을 등록하고 공부를 시작했다.해외 여행을 갈 때나 언젠가 해외에 나가서 공부하고, 일하기 위해서는 영어를 전문연구요원을 할 때인 지금 여유가 있을 때 조금 공부해야된다고 생각이 들었다.솔직히 이때까지 영어공부를 열심히 하지도 않았고.. 개발 관련된 문서말고는 영어로 되는 걸 읽은 적이 많지 않은거같다. 그래서 많이 부족함을 느끼고 있고, 내년까지 꾸준히 회화를 공부해서 자연스러운 일상 대화 하는 것이 목표다.평일엔 하루에 적어도 30분 정도를 투자하려고하고, 주말엔 2~5시간 정도 공부를 하고 있다.이정도 공부량으로 힘들 수 있겠지만 일단은 꾸준하게 해보려고한다. 내년에 유창하게 말할 수 있기를!2022년 총평되게 힘들기도 했지만 많은 성취를 이루기도 한 해였던거 같다.그리고 어떠한 일을 시작하기도하고, 무언가를 주저하기도 했다. 매 해 정신없이 살아가는 것 같지만 올해는 유독 더 그랬던 것 같다.새로운 사람들도 많이 만나서 친분을 쌓고 많은 대화를 나누기도 했다. 그리고 누군가와는 인연이 끊기기도 했다.매 해 있는 일이지만 나한텐 항상 특별하기도 하고 힘들기도 한 일 이기도하다.내가 아직 성숙한 어른이 아니라 그런 걸 수도 있고 나라는 사람이 그런걸 수도 있지만 내년엔 조금 더 성장한 사람이 됐으면 좋겠다는 바람으로 2022년 회고를 마친다 😄이 글을 보는 모두가 다음해에 축복을 빈다🥳🥳🥳🥳" }, { "title": "Atomic Design Pattern", "url": "/posts/post32/", "categories": "Web, 디자인패턴", "tags": "Atomic, Design Pattern, Atomic Design", "date": "2022-11-15 00:00:00 +0900", "snippet": "Atomic Design Pattern우리가 학창시절에 배우는 화학에 영감을 얻어 만들어진 디자인 패턴이다.고등학교 과정을 받으면 다 아는 정도에 화학 지식이면 충분하기 때문에 걱정할 필요는 없다…! 원자가 어떠한 물질을 이루는 가장 작은 단위이고, 원자가 결합해 분자를 형성한다 그리고 분자들이 모여 유기체를 만든다.위와 같은 개념으로 컴포넌트를 구성할 수 있게 도와주는 정신적인 모델이다. 선형적으로 개발할 필요는 없으며, 단지 5단계로 이루어져 있는 각각의 인터페이스가 계층적으로 역할을 할 수 있게 개발하면 된다.bradfrost라는 개발자가 만들었고 본인이 잘 정리한 사이트도 있다!기본적으로 5 단계로 이루어져 있고 순서는 원자 - 분자 - 유기체 - 템플릿 - 페이지 이다.이제 하나씩 어떤 역할을 하는지 훑어보겠다.Atom (원자)Atom은 더 이상 분해될 수 없는 객체로 구성하게 된다.Button, Input, Card, Label 등의 기능을 중단시키지 않는 이상 분해될 수 없는 객체, 보통은 HtmlElement을 Wrappring 해서 많이 구성한다.디자인 패턴 맥락에서 Atom은 기본 스타일을 보여주며, 재사용이 굉장히 용이하다.Atom은 무조건 Molecules로만 결합되는 것이 아닌 Molecules과 함께 Organisms을 구성할 수도 있으며 여러 단위들과의 조합이 가능하다.Molecules (분자)Molecules은 Atom들이 결합된 그룹이다. 예를 들어 물 분자와, 과산화소수의 분자가 동일한 원자구조를 가지고 있지만 다른 특성을가지고 기능하는 것을 보면 알 수 있겠지만 같은 Atom으로 생성한 컴포넌트를 이용해 Molecules를 형성해도 고유한 형태로 만들어 낼 수 있다.위에 이미지 같이 SearchForm을 만들게되면, SRP(단일 책임 원칙)을 준수해 한 가지 일을 수행하는 재사용과 테스트하기 좋은 mocules를 만들 수 있다.Organisms (유기체)위에 원자와 분자와는 다르게 조금 복잡한 구조이다. 각각이 다른 분자들을 조합해서 유기체를 만들 수도 있고, 반복되는 분자들을 만들어서 유기체를 구성할 수도 있다.보통 위에 이미지처럼 하나의 섹션을 보통 담당하며, 재사용성은 매우 떨어진다.Template여기서부턴 화학 비유가 끝나게 된다. (bradfost의 말로는 화학 비유로 너무 멀리 나아가면 미친사람 취급을 당할 수 있다고 한다)위에 만든 구성요소들을 레이아웃에 배치하고, 기본 콘텐츠 구조를 생성한다. 골격이 만드는 페이지라고 생각하면 편하다.PagePage는 가장 구체적인 데이터들을 다루는 부분이다. Template이 구성된 곳에 실제 데이터를 넣고, 기본 콘텐츠 구조와 디자인이 동적특성을 잘 반영하는지 테스트할 수 있다. 나는 보통 Organism부터는 재사용이 힘들다고 생각하고 Context를 사용해 구성하기도 한다. Organism과 Mocules에 대한 구분은 프로젝트 특성이나 사람마다 다른 것 같아서 본인이 재사용성을 높이고, 다른 단계들과 잘 융합될 수 있는 작업을하면 될 것 같다." }, { "title": "RxJS (feat.반응형 프로그래밍)", "url": "/posts/post31/", "categories": "Web, JavaScript", "tags": "RxJS, 비동기 프로그래밍, 반응형 프로그래밍", "date": "2022-11-14 00:00:00 +0900", "snippet": "RxJs개요RxJs의 용도는?Think of RxJS as Lodash for events.(RxJs를 이벤트용 Lodash로 생각하라)처음에 RxJs의 공식 문서를 살펴보면 이게 정확히 무슨 용도로 쓰이고 어떤 효용성이 있는지 파악하기 힘들다.작성자도 같은 생각이었는지 위와 같이 설명한다.내가 생각하는 RxJs의 용도는 간단히 말하면 비동기 코드와 시간 관련된 코드를 쉽고 간결하게 작성하게 도와주는 것 이다.만약에 아래조건으로 자동완성을 처리를 해야된다고 생각해보자 타이핑 할 때마다 서버에 데이터를 받아서 보여주세요 너무 잦은 요청은 서버에 부하를 줄 수 있으니 타이핑 간격이 좁으면 대기하다가 입력이 늦어지면 그 때 요청해주세요 같은 내용일 때는 요청하지 마세요 일정 시간 동안 응답이 없으면 3회 재시도하고 그래도 응답이 없으면 에러메시지를 출력해주세요 데이터는 캐시로 보관하여 먼저 보여주고 요청이 완료되면 변경된 데이터를 표시해주세요 위와 같은 조건을 Async/Await 혹은 Promise를 이용한다고 생각해보자 굉장히 복잡하고 어려운 코드를 만들게 될거다.RxJS를 이용했을 때 코드는 아래와 같다.let autoCompleteRef;const inputElement = document.createElement(&quot;input&quot;);const request = (data: any) =&amp;gt; fromFetch(&quot;url&quot;);const input$ = fromEvent &amp;lt; HTMLInputElement &amp;gt; (inputElement, &quot;input&quot;); // Event -&amp;gt; Observableinput$ .pipe( map((event) =&amp;gt; event.value), distinctUntilChanged(), // 3 - 중복되는 요청 막기 debounceTime(500), // 2 - 연속되는 타이핑 제어 mergeMap((text) =&amp;gt; request(text).pipe( map((res) =&amp;gt; res.text), tap((value) =&amp;gt; (autoCompleteRef = value)), // autoCompleteElement 처리 timeout(7000), // 4 - 7초동안 서버의 응답이 없으면 timeout 처리 retry(3), // 3번 재시도 catchError((e) =&amp;gt; e) ) ) ) .subscribe();코드를 보면 떠오르는게 있다! 마치 Array가 떠오르지 않나? 그래서 많은 사람들이 rxjs를 비동기 처리를 Array처럼 처리 할 수 있게 해주는 라이브러리라고 칭하기도 한다.저 처리들을 모두 async/await 혹은 Promise로 처리한다고 생각해보자 저거보다 코드를 더 작성해야할 것이고 가독성도 좋지 않을 것이고, subscribe와 같은 observable 처리는 또 따로 해줘야 할 것이다. 물론 부가적인 기능이 더 있을 수 있지만 주로 이런 처리를 위해 RxJs를 사용한다.EveryThing is a StreamStream이란 말은 프론트엔드 개발자에게 굉장히 친숙하다. stream은 실시간으로 계속 변경되는 데이터를 Chunk 단위로 받아 처리하는 것을 뜻한다.예를 들면 Netflix와 같은 OTT 동영상 데이터를 받아 처리하는 것이나 화면 상에 움직이는 마우스 좌표 사용자가 입력하는 키보드 값 등 거의 모든 것을 Stream으로 표현할 수 있다.반응형 프로그래밍 (Pull, Push)반응형 프로그래밍은 생각보다 우리 주변에서 쉽게 접할 수 있다.가장 쉬운 예로는 Excel이 있다! 가령 A1+B1 이라는 수식을 C1에 적어둔다면 A1과 B1이 변경될 때마다 C1이 알아서 반응하여 숫자를 변경한다.그리고 Javascript에서 addEventListener 또한 반응형이다! event를 등록하고, event가 발생할 때 반응하여 여러 작용을 하는 방식이다.반응형 프로그래밍은 Push 방식의 데이터 패러다임을 가지고 있다.PullPull은 Promise가 제일 대표적이다. 사용자가 필요할 때마다 데이터를 요청해서 사용하는 방식이다. 레거시 데이터나 중복 요청이 있을 수 있다.PushPush는 Subscribe된 값이 변경될 때마다 전파된 데이터를 받아 항상 최신의 데이터를 유지할 수 있다.Observable (생성자)Observable은 RxJS에서 가장 중심이 되는 역할을 한다. observer 을 인자로 받고 함수를 반환하며, Subscribe할 수 있는 역할이다.Observable은 Promise와 같이 하나의 객체로 생각해야되며, Observable은 기본적으로 일반 function과 같이 동기적으로 작동한다.하지만 함수와 다른점은 반환 에 있다.비동기 적 반환과, 동기식으로 여러 개의 값을 반환할 수 있다.// 일반 함수function foo() { return 42; return 100; // 죽은 코드이며 실행할 수 없는 코드다}import { Observable } from &quot;rxjs&quot;;// Observableconst foo = new Observable((subscribe) =&amp;gt; { console.log(&quot;test&quot;); subscribe.next(&quot;1&quot;); // 이런식으로 여러 값을 리턴할 수 있다. subscribe.next(&quot;10&quot;); subscribe.next(&quot;10&quot;); interval(3000, () =&amp;gt; { subscribe.next(&quot;result&quot;); // 비동기 반환 });});foo.subscribe((x) =&amp;gt; { console.log(x);});output&quot;test&quot;&quot;1&quot;&quot;10&quot;&quot;10&quot;3초 뒤 ..&quot;result&quot;subscribe생성된 observable에 대한 subscribe 를 정의 할 수 있고, 전달될 데이터의 콜백과 다를게 없다.Subscription 이라는 객체를 반환하며 이 객체는 오직 unsubscribe를 처리하는 용도로만 사용된다.Observable 실행next실제 데이터를 Subscription에게 전달하는 함수.Error예외가 발생했을 때 Subscription에게 전달하는 함수 Observable Execution 동안 한 번의 실행만 가능Complete실행이 다 완료되었을 때 전달하는 함수 Error와 마찬가지로 한 번의 실행만 가능하며 둘 중에 하나만 있을 수 있다.Observable 실행 중지observable.subscribe() 실행시 Subscription이 반환된다. 그 반환된 객체로 unsubscribe 처리를 해주면 된다.subscription.unsubscribe();Observer (소비자)Observer은 Observable에서 전달되는 값을 유형별로 처리하는 콜백 세트이다.next, error, complete 과 같이 Observable에서 실행하는 함수와 같다.Operator (연산자)Operator는 함수를 실행하고 Observable을 반환하는 함수이다.연산자는 두 가지 종류가 있다.Pipe 가능한 연산자해당 연산자는 Observable에 파이프할 수 있는 종류이다. 여기에는 filter, mergeMap이 포함된다. 그리고 구독 로직이 첫 번 째 Observable을 기반으로하는 새로운 Observable을 반환한다.PipePipe는 Rxjs 5.5부터 도입된 개념이고, RxJs의 범위가 커지면서 Method방식은 Tree-Shaking에 불리하여 Pipe같은 Operator 함수로 분리하면 import를 한 만큼만 번들링이 되기 때문에 번들링의 크기를 줄일 수 있게 된다.만약에 클릭이 3번 이상 일어났을 때 어떠한 동작을 한다고 생각하면 Dot Chain 방식에서는 아래와같은 코드를 사용할 수 있다.import { Observable } from &#39;rxjs&#39;const obs = fromEvent(window,&quot;click&quot;).bufferTime(250).filter(click =&amp;gt; click.length === 3).subscribe(~~)Pipe 연산자로 그대로 옮긴 다면 다음과 같다.const pipe$ = fromEvent(window, &quot;click&quot;) .pipe( bufferTime(2500), filter((click) =&amp;gt; click.length &amp;gt;= 3) ) .subscribe((value) =&amp;gt; { console.log(`value:${value}`); });Create Operator (생선 연산자)미리 정의된 몇 가지 일반적인 동작을 사용하거나 다른 Observable을 결합하여 Observable을 생성하는데 사용할 수 있는 함수들이다.예를 들어 Interval이 있습니다.// Observable 생성const observable = interval(1000);더 많은 것들은 공식문서를… Event도 있고 데이터끼리 join을 해서 Observable을 생성하는 것도 있습니다.Cold ObservableObservable 내에서 데이터를 생산하는 경우를 일컫는 말이다.Observable은 기본적으로 무언가가 구독할 때만 값을 실행하게 되는데 각 구독자에 대해서 새로운 실행을 시작하므로 데이터가 공유 되지 안는다.코드로 예를 든다면 아래와 같다.import * as Rx from &quot;rxjs&quot;const observable = of(0,1).pipe( next(Math.random());)observable.subscribe((dt) =&amp;gt; { console.log(dt); // 0.235314123324});observable.subscribe((dt) =&amp;gt; { console.log(dt); // 0.712341231124});구독자에 대해서 새로운 실행을 수행하기 때문에 구독자가 받는 데이터는 다르게 되는 동작이다.Cold 방식은 애니메이션이나 계속해서 함수가 생성되어 변화를 감지해야하는 것들이 어울린다.Hot ObservableHot 방식은 Cold와는 반대로 Observable 외부에서 데이터를 받는 방식이다.코드로 예를 든다면 아래와 같다.import * as Rx from &quot;rxjs&quot;const random = Math.random();const observable = of(0,1).pipe( next(random);)observable.subscribe((dt) =&amp;gt; { console.log(dt); // 0.235314123324});observable.subscribe((dt) =&amp;gt; { console.log(dt); // 0.235314123324});구독자가 있든 없든 데이터가 생성되기때문에 구독자가 없다면 쓸 때없는 데이터에 메모리를 사용하는 경우가 될 수 있다.Hot 방식은 API를 호출하거나 상태관리를 할 때 어울리는 방식이다.SubJectSubject는 Observable과 Observer 역할 모두 수행할 수 있으며, subscribe할 수 있으며 동시에 pipe도 가능하다.Subject로 Hot Observable을 사용할 수 있다.Subject의 기능은 여러 Observer에 멀티캐스트할 수 있다.코드로 예를 든다면 아래와 같다.const subject = new Subject();subject.subscribe((val) =&amp;gt; console.log(val)); // 0.123123subject.subscribe((val) =&amp;gt; console.log(val)); // 0.123123subject.next(Math.random());UseObservableimport { useEffect, useMemo, useRef, useState } from &quot;react&quot;;import { BehaviorSubject, combineLatest, from, map } from &quot;rxjs&quot;;const useObservedValue = (observable: any) =&amp;gt; { const [value, setValue] = useState(); const subject = useRef(new BehaviorSubject(observable)); useEffect(() =&amp;gt; { subject.current.next(value); return () =&amp;gt; { subject.current.unsubscribe(); }; }, [value]); return useMemo(() =&amp;gt; subject.current.asObservable(), [subject]);};const test = () =&amp;gt; { const [title, setTitle] = useState&amp;lt;string&amp;gt;(&quot;&quot;); const myObservaed = useObservedValue(&quot;value&quot;); myObservaed.subscribe((value) =&amp;gt; { console.log(value); });};API 호출 시 유용한 함수Promise 값이나 iterator을 가진 값은 From 메소드로 Observable 형식으로 변환시킬 수 있다.ForkJoinForkJoin에 모든 Observable이 완료되는 것을 기다린 후 해당 Observable의 마지막값들을 return한다.Subject에서 여러 API를 호출한 뒤에 하나의 결과로 모아볼 수 있는 API이다.예제 코드import { forkJoin, of, timer } from &quot;rxjs&quot;;const observable = forkJoin({ foo: of(1, 2, 3, 4), bar: Promise.resolve(8), baz: timer(4000),});observable.subscribe({ next: (value) =&amp;gt; console.log(value), complete: () =&amp;gt; console.log(&quot;This is how it ends!&quot;),});// Logs:// { foo: 4, bar: 8, baz: 0 } after 4 seconds// &#39;This is how it ends!&#39; immediately afterMergeMapForkJoin과는 다르게 Observable 중 하나가 완료될 때 마다 ID를 사용하고 반응이 가능한 API예제코드import { of, mergeMap, interval, map } from &quot;rxjs&quot;;const letters = of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);const result = letters.pipe( mergeMap((x) =&amp;gt; interval(1000).pipe(map((i) =&amp;gt; x + i))));result.subscribe((x) =&amp;gt; console.log(x));// Logs:// a1// b1// c1// a2// b2// c2// a3// b3// c3CombineLatestObservables 배열에 전달된 모든 Observables의 값을 결합한다.@akanass/rx-http-requestAPI를 호출하여 바로 Observable을 반환하여 Subscribe에게 전달할 수 있는 라이브러리이다." }, { "title": "Graph", "url": "/posts/post30/", "categories": "자료구조", "tags": "알고리즘, DFS, BFS, Dijkstra, Floyd-Warshall", "date": "2022-10-03 00:00:00 +0900", "snippet": "GraphGraph 는 정점(vertex)과 간선(edge)으로 이루어져 있는 자료구조이다.데이터 항목 간의 관계를 나타내는데 사용되며 소셜 네트워크, 교통 네트워크 등과 같은 광범위한 데이터를 나타내는데 사용된다.보통은 어떠한 목적지에 대한 최단 경로와 지도 등의 연결되어 있는 객채 간의 관계들을 표현할 때 사용한다.아래는 Javascript 코드로 Graph 자료구조를 구현한 코드이다.Javascript Codeclass Graph { constructor() { this.vertices = []; this.edges = []; } addVertex(vertex) { this.vertices.push(vertex); } addEdge(vertex1, vertex2) { this.edges.push([vertex1, vertex2]); }}const graph = new Graph();graph.addVertex(&quot;A&quot;);graph.addVertex(&quot;B&quot;);graph.addVertex(&quot;C&quot;);graph.addEdge(&quot;A&quot;, &quot;B&quot;);graph.addEdge(&quot;B&quot;, &quot;C&quot;);위의 예에서 Vertex는 꼭짓점 하나의 지점을 나타내느 속성이 있고, Edge는 Vertext 과의 관계를 연결하는 간선을 만들게 된다.Graph 검색에 대한 알고리즘은 대표적으로 BFS(Breadth Frist Search), DFS(Depth First Search)가 있으며 그 외에도 다익스트라, 크루스칼 등 여러가지 알고리즘이 있다." }, { "title": "React에 StoryBook 셋업하기!", "url": "/posts/post29/", "categories": "Web, React", "tags": "React, Testing, StoryBook", "date": "2022-09-01 00:00:00 +0900", "snippet": "Storybook installstorybook 설치npm i @storybook/reactstorybook initnpx storybook initStorybook settingstories/main.jsmodule.exports = { addons: [&quot;@storybook/addon-essentials&quot;], babel: async (options) =&amp;gt; ({ ...options, }), framework: &quot;@storybook/react&quot;, stories: [&quot;../src/**/*.stories.@(js|mdx)&quot;], webpackFinal: async (config, { configType }) =&amp;gt; { return config; },};위에는 storybook에서 제공하는 main.js configuartion 코드이다. addons - 스토리북에서 사용하는 bable로 치면 plugin같이 서드파티 혹은 다른 라이브러리와 상호작용하기 위한 목록 babel - storybook build 시에 babel 구성 webpackFinal - storybook build 시에 webpack 구성 framework - 로딩 및 빌드 프로세스를 돕기 위한 프레임워크 구성 stories - 스토리 파일의 위치 button.stories.tsxexport default { title: &quot;button&quot;, component: Button, argTypes: { label: { description: &quot;overwritten description&quot;, table: { type: { summary: &quot;something short&quot;, detail: &quot;something really really long&quot;, }, }, control: { type: &quot;text&quot;, }, }, },};export const Default = (props: BunttonProps) =&amp;gt; { return &amp;lt;Button {...props}&amp;gt;Example&amp;lt;/Button&amp;gt;;};Default.storyName = &quot;Default&quot;;Default.args = { color: &quot;primary&quot;,};위와 같이 스토리를 생성한 컴포넌트로 기반으로 작성할 수 있으며, args로 초기 argument들을 정의할 수 있고,argTypes를 통해 storybook 내에서 설정한 control을 사용해 props 값을 변경할 수 있다." }, { "title": "프론트엔드 개발자 취업 후기", "url": "/posts/post28/", "categories": "일상", "tags": "일상, 잡담", "date": "2022-08-29 00:00:00 +0900", "snippet": "시작 전에이 후기는 굉장히 주관적이며 제 방식이 맞다고 생각하는 것도 아니고, 따라하라는 글이 아닙니다.누군가 이 후기를 보고 조금이라도 도움이 되고 즐거운 시간이 됐으면 해서 작성하는 글입니다.(저는 취준 기간 동안 누군가 취직한 후기를 많이 보고 동기부여도 되고 실제로 팁도 얻었습니다.)회사 리스트업이번달 2022-08-19일자로 취업 성공을 했고 전문연구요원으로 편입하여 지금 회사에서 근무하면서 적응하는 중이다.먼저 나는 석사 전문연구요원으로 편입해야 했고, 프론트엔드 경력으로 취직해야했기 때문에회사를 리스트업했다.그리고 결과와 진행상황을 노션으로 아래처럼 정리했다. (솔직히 막판엔 좀 귀찮아서 안 한거 안 비밀…) 꽤나 처참하다? 물론 이거 말고 더 넣었음취업 준비그리고 MBTI 당당한 J인 나는 취직을 올해 6월 부터 준비하고 7~8월을 목표로 취업 계획했다.먼저 나는 3개의 키워드로 준비했는데 아래와 같다. 포트폴리오 코딩테스트 면접포트폴리오먼저 포트폴리오는 자신이 지원하는 분야에 대해 내가 이만큼~~ 할 수있어! 라고 말한다고 생각하면 된다.그 말은 내가 포폴을 다 숙지하고 옳게 대답할 수 있다면 무기가 될 수 있고, 그 반대라면 면접관에게 나를 향해 휘두룰 수 있는 무기를 쥐어 주는 셈이다.깃허브에 소스를 하나하나 까보는 면접관도 있었고, 아닌 면접관도 있었지만, 본인의 포트폴리오에 사용하는 기술이나 소스코드를 하나하나 모두는 아니여도 전반적으로 무조건!! 숙지하고 있어야 한다. (그리고 본인이 짜는 코드나 라이브러리를 이해 못하는 사람은 조금 더 개발을 해보고 취준을 하는 것을 추천한다.)그리고 내가 포폴에서 가장 많이 준비했던 것은 기술을 사용한 타당한 이유 였다.프론트엔드는 굉장히 초기 세팅의 자율성이 많기 때문에 (빌드 도구만 해도 WebPack, Rollup, Vite 등) 이런 여러 라이브러리를 선택하는 이유가 분명해야 한다.본인이 무슨 라이브러리를 왜 쓰는지도 모르고 사용했다 하면 바로 광탈이다…그리고 소스를 조금만 봐도 와 이사람 잘한다 말하게 할 자신이 없다면 ReadMe를 이쁘게 꾸미고, 만약 웹사이트라면 보이는 UI를 이쁘게 꾸미자 이쁜떡이 먹기도 좋다고 있어보이는게 최고다! (반박시 님 말 맞습니다…)코딩테스트코딩테스트는 대부분의 회사는 실행한다. 나는 이전까진 코테 준비를 딱히 하지 않았고 딱 6월 부터 하루에 한 시간 ~ 두시간 정도 백준 문제집에 삼성 기출 문제를 풀었다. 동빈 나 - 이것이 코딩 테스트다. 책이랑 같이 유튜브를 시청해서 초반 개념을 잡았다.요즘은 구현 문제가 많이 나오기도하고, BFS와 DFS 그리고 DP 몇 개 까지 준비할 수 있는 좋은 문제집인거 같다.그리고 대부분의 프론트엔드 코테는 공채 아니면 javascript로 하기 때문에 python으로 한다면 포팅하는 방식으로 풀던가 javascript로 하는 연습이 필요하다. 사실 나도 코테 잘 못해서 많이 떨어졌다 ㅠㅠ 회사 근무하면서 꾸준하게 공부해보려고 한다.면접보통 면접은 1차 기술면접 2차 인성면접으로 나누어서 보게된다.기술면접은 ESNext, ReactJs, NextJs, 빌드 도구(webpack), css, html 정도를 준비했다.그리고 코테 보는 곳은 코테코드에 대해 물어보는 곳도 있었다.사실 프론트엔드 기술면접 자료는 너무 많아서 링크를 남긴다.거의 아래 두 개로 모두 커버된 것 같다.캡틴판교님 - https://joshua1988.github.io/web-development/interview/frontend-questions/github - https://github.com/baeharam/Must-Know-About-Frontend인성 면접도 사실 유튜브나 구글에 너무 많이 나와있어서 그걸 보고 공부했다.그리고 말이 꼬이지않게 혼자 나불나불 연습했다.그리고 면접 후 꼭!!!! 복기해라 진짜 중요하다 이게 인성면접이든 기술면접이든 정말 중요하다.내가 부족한게 무엇인지 알 수 있고 대답을 잘했다 생각한 것도 보완할게 나온다.최종 합격 후온보딩 전에 보통 오퍼레터가 오고 협의를 하게된다. 연봉이 마음에 들면 바로 ㄱㄱ 하면되고, 안들면 카운터 오퍼를 보내면 된다. 글 재주가 없기 때문에 생략…마지막으로취준하시는 분들 많이 고생하시고 힘든 걸 알고있다. 그래도 열심히 꾸준히 준비하면 좋은 결과가 있을거라 믿는다!취준생 분들 모두 화이팅입니다!!!" }, { "title": "OSI 7 계층과 TCP/IP 4계층", "url": "/posts/post27/", "categories": "CS, 네트워크", "tags": "Network, OSI, TCP/IP", "date": "2022-08-15 00:00:00 +0900", "snippet": "OSI 7계층전 세계적으로 가장 기반이 되고있는 네트워크 표준 모델이다.네트워크 통신에 사용되는 전반적인 프로토콜이 모두 포함되어 있다.layer 1 - 물리(Physical) 계층가장 첫번 째 단계인 물리 계층은 우리 피씨 혹은 노트북과 연결되어있는 와이파이 혹은 이더넷 연결 선으로 연결되어있는 케이블로 데이터를 전달하는 계층을 말한다.주로 비트(0/1)로만 데이터를 주고받는다. ex) 허브, 리피터, 케이블 등layer 2 - 데이터 링크(Data Link) 계층데이터 링크 계층은 물리적 계층을 통해 가까운 노드간에 데이터를 전달하는 프로토콜 계층이다.물리 계층에서 발생하는 오류를 감지하고, 재전송하는 기능을 가지고 있고, 맥 주소(Mac Address)를 통해 통신하게 된다.장치 간의 신뢰성 있는 전송을 보장하기 위한 계층이다. ex) 브리지, 스위치 (전송단위: 프레임)layer 3 - 네트워크 (Network) 계층네트워크 계층은 어디가에 있는 목적지 컴퓨터로 데이터를 전송하기 위해존재하는 계층이다. (Routing)IP 주소를 이용해 길을 찾은 뒤 자신 다음의 라우터에게 데이터를 전달하는 것이다. ex) 라우터 (전송단위: 패킷)layer 4 - 전송 (Transport Layer) 계층일반적으로 네트워크 통신을 할 때 수신자 컴퓨터에있는 프로세스의 포트 번호를 붙여서 보내면 수신된 포트에 걸맞게프로세스를 찾아 데이터를 실행하게 된다.전송 계층은 위 과정을 통해 최종 도착지인 프로세스에 까지데이터가 도달하게 하는 모듈이다.layer 5 - 세션(Session) 계층데이터가 통신하기 위한 논리적인 연결을 말한다.layer 6 - 표현(Presentation) 계층통신하는 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다.코드 간의 번역을 담당하여 사용자 시스템의 형식상 차이를 다루는 동작을한다.해당 데이터가 TEXT인지, JPG인지 구분하는 기능을 하는 계층이다.layer 7 - 응용(Application) 계층최종 목적지로 HTTP, FTP, SMTP 등의 프로토콜이 있으며, 어플리케이션 프로토콜을 통해 응용 서비스에서 네트워크를 통해 송수신된 이진 데이터를 넘겨받는 계층이다." }, { "title": "프로세스와 쓰레드", "url": "/posts/post26/", "categories": "CS, 운영체제", "tags": "Process, Thread, Multi Process", "date": "2022-08-07 00:00:00 +0900", "snippet": "메모리 구조프로세스와 쓰레드를 이해하기 전에 메모리 구조를 먼저 알고가면 좀 더 쉽게 이해가 가능하다.출처: http://www.tcpschool.com/이미지와 같이 메모리는 Stack, Heap, Data, Code 영역으로 구분된다. Stack - 함수 호출 시 생성되는 지역변수와 매개변수를 저장하는 메모리 영역 Heap - 런타임 중에 동적으로 할당/해제 되는 메모리 영역 Data - 전역변수와 static 변수가 저장되는 메모리 영역 Code - 컴파일 후 기계어로 저장된 코드가 저장되는 메모리 영역Heap은 동적으로 메모리를 할당/해제 되는 특성 때문에 heap영역과 stack 영역 사이에 공간이 있는 것을 확인할 수 있다.프로세스란(Process)?프로세스는 프로그램이 메모리 내에 적재되어 CPU를 할당받아 실행되는 것을 프로세스라 하는 것이다.프로세스 = 프로그램 이라고 말해도 어떻게 보면 맞는 말이라 할 수 있다.코드를 작성해 컴파일 한 후 하드디스크에 저장되어있는 것을 프로그램이라고 하고,CPU가 프로그램을 연산하기 위해서 RAM 영역에 적재한 것을 프로세스라고 한다.프로세스는 다른 프로세스와 메모리 영역을 공유할 수 없으며 예로는 구글 크롬 브라우저의 탭이 있다.그걸 보면 탭끼리 서로 영향을 안주는 것을 알 수 있다.쓰레드 (Thread)쓰레드는 위에 프로세스가 서로 메모리를 공유하지 못하는 특성을 보완하기 위해 만들어진 프로세스 내에서 독립적인 기능(독립적인 함수 호출)을 수행할 수 있는 작업 단위이다.쓰레드는 Stack 메모리를 제외한 나머지 memory 영역(heap, data, code)을 공유할 수 있고, 이렇게 하나의 process가 동시에 thread를 여러 작업을 병렬로 처리하는 것을 multi thread라고 한다.stack을 제외하는 이유는 위에 언급한 독립적인 기능을 수행하기 위해선 각자의 stack memory가 필요하기 때문이다.멀티 쓰레드의 예를 얘기하자면 트위치 스트리밍 같은 것이 있다.영상 데이터를 가져와야 하고, 댓글을 써야하고, 하나의 프로세스 내에서 여러가지 기능을 독립적으로 수행할 수 있는 것을 확인할 수 있다." }, { "title": "React에서 SSR (NextJS vs Gatsby)", "url": "/posts/post25/", "categories": "Web, React", "tags": "React, SSR, NextJs, Gatsby", "date": "2022-08-05 00:00:00 +0900", "snippet": "React SSRGatsby와 NextJS를 비교하기 전에 왜 이런 프레임워크를 써야하는지 알 필요가 있다.React에서 CRA로 프로젝트를 생성하게되면 SPA 기반 라이브러리로 CSR을 사용해 개발을 하게 된다.CSR이 가지는 장점도 있겠지만, SEO와 초기 렌더링 문제 등 CSR의 한계로 인해 오늘 날은 CSR + SSR 형태로 많이 개발을 하게된다.하지만 CRA로 React를 구성한다면 SSR은 직접 구현을 해야하낟.React에서 SSR을 구현하려면 어떻게 해야할까?React에서 SSR 구현에 대한 포스팅이 아니기 때문에 간략하게 설명을 한다. React-router와 @loadable-component를 사용해 SSR을 지원하는 Code-splitting을 사용한다. React-helmet을 통해 SEO에 대응한다. Webpack과 babel을 설정한다. (node(server), web(client)) 2 종류로 컴파일 해야한다. 서버측에서 ReactDOM.hydrate을 이용해 렌더링한다.이러한 과정을 직접 개발하고 개발도 중 계속 설정을 변경해야할 일이 생길 수 있다.그래서 우리는 프레임워크를 통해 SEO를 제공하거나 CSR + SSR 형식으로 개발할 수 있다.본 포스팅에선 대표적으로 사용하는 NextJs와 Gatsby를 비교한다.NextJS현재 가장 많이 사용하고 있는 SSR 프레임워크이다.자세한 설명은 NextJS를 포스팅 한 적이 있어 해당 NextJs란? 포스팅에서 확인 가능하다.GatsbyGatsby는 정확히 말하면 SSR은 아니고 SSG(정적 페이지 렌더링) 즉 정적으로 HTML을 구축해 SEO을 대응하고, GraphQL과 React가 결합되어 있다.SSG 형태의 최적화가 잘 되어있고, 여러 플러그인을 제공하여 작업(코드) 량을 줄일 수 있다.하지만, 서비스가 커지면 정적으로 생성할 페이지나 파일 크기가 늘어나기 때문에 빌드시간, 파일 사이즈가 계속 늘어나게 되고, 많은 플러그인들은디펜던시를 갖게 되어 Gatsby의 버전 업데이트에 따라 빌드가 되지 않을 수 있다.NextJS vs Gatsby나의 개인적인 견해이지만 두 프레임워크의 사용방법은 정확히 구분할 수 있을 것 같다.Gatsby의 경우는 블로그나 렌딩 페이지 혹은 CMS 등의 정적인 데이터가 많고서비스가 크지 않을 때 모두 SSG로 렌더링 하여 성능면의 이점을 가져갈 수 있고,NextJS의 경우에는 유저와의 상호작용으로 데이터가 변경되거나,앱내의 웹뷰 처럼 데이터가 수시로 변경되는 것들은 NextJS를 이용하는게 맞는 것 같다.사용자의 동작을 예측하고 SSG로 구성하는 것은 불가능하고, CSR을 이용한다면 SSG의 장점을이용하지 못하기 때문에 이런 경우엔 NextJS가 맞는 것 같다.두 프레임워크 모두 용도에 맞게 사용하면 좋은 프레임워크이다.Gatsby는 SSG 성능 최적화 NextJS는 SSR과 SSG 그리고 개발의 유연성, 빌드 등을 중점을 두고 만들어진 느낌이다." }, { "title": "React v18 변경 사항 톺아보기", "url": "/posts/post24/", "categories": "Web, React", "tags": "React, v18", "date": "2022-07-29 00:00:00 +0900", "snippet": "React v18React에서 중요시하는 동시성에 관련한 사항들과 Suspense가 주요 업데이트 사항인것 같다.Automatic Batching (자동 일괄 처리)batching 처리란?동일한 클릭 이벤트 내에 두 개의 상태 업데이트가 있는 경우 React는 항상 이를 하나의 재렌더링으로 일괄 처리한다.다음 코드를 실행하면 클릭할 때마다 상태를 두 번 설정하더라도 React는 단일 렌더링만 수행하는 것을 볼 수 있다.불필요한 재렌더링을 줄여 성능을 확보하는 렌더링 방식이였다.function App() { const [count, setCount] = useState(0); const [flag, setFlag] = useState(false); function handleClick() { setCount((c) =&amp;gt; c + 1); // 리렌더링이 일어나지않음 setFlag((f) =&amp;gt; !f); // 리렌더링이 일어나지않음 // React에선 한번의 렌더링으로 일괄처리 } return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={handleClick}&amp;gt;Next&amp;lt;/button&amp;gt; &amp;lt;h1 style=&amp;gt;{count}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}하지만 React에서 일괄 처리는 일관성이 없었다. 예를들어 다른곳에서 데이터를 불러와 State를 업데이트하는 경우엔 각자 독립적인 렌더링이 일어났다.function App() { const [count, setCount] = useState(0); const [flag, setFlag] = useState(false); function handleClick() { fetchSomething().then(() =&amp;gt; { // 콜백 이밴트는 이벤트가 종료됐다고 판단하여 일괄처리가 되지 않음 setCount((c) =&amp;gt; c + 1); // 리렌더링 setFlag((f) =&amp;gt; !f); // 리렌더링 }); } return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={handleClick}&amp;gt;Next&amp;lt;/button&amp;gt; &amp;lt;h1 style=&amp;gt;{count}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}위와 같이 react 이벤트 핸들러가 아닌 Promise, setTimeout, 기본 이벤트 핸들러 등에서는 React에서 일괄처리를 할 수 없었다.Automatic Batching (자동 일괄 처리)React v18에서는 createRoot 내에 모든 업데이트는 출처와 상관없이 자동으로 일괄 처리하게끔 변경 되었다.아까와 같은 코드로 예를 들자면 아래와 같고 batching을 차단하고 싶으면 flushSync API를 사용하면 된다.function App() { // React 18 버전 이후 import { flushSync } from &quot;react-dom&quot;; const [count, setCount] = useState(0); const [flag, setFlag] = useState(false); function handleClick() { fetchSomething().then(() =&amp;gt; { flushSync(() =&amp;gt; { setCount((prev) =&amp;gt; prev + 1); }); // 리렌더링 setCount((c) =&amp;gt; c + 1); setFlag((f) =&amp;gt; !f); // 그 후로 한 번의 리렌더링 }); } return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={handleClick}&amp;gt;Next&amp;lt;/button&amp;gt; &amp;lt;h1 style=&amp;gt;{count}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}적용하기 위해선 새로 추가된 react-dom/client API인 createroot 태그로 루트를 생성해야한다.// React v17import * as ReactDOMClient from &quot;react-dom/client&quot;;function App() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOMClient.render(&amp;lt;App /&amp;gt;, rootElement, () =&amp;gt; console.log(&quot;renderered&quot;));위와 같은 방식에서 아래와 같은 방식으로 변경할 수 있다.import * as ReactDOMClient from &quot;react-dom/client&quot;;function App({ callback }) { // Callback will be called when the div is first created. return ( &amp;lt;div ref={callback}&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}const rootElement = document.getElementById(&quot;root&quot;);const root = ReactDOMClient.createRoot(rootElement);root.render(&amp;lt;App callback={() =&amp;gt; console.log(&quot;renderered&quot;)} /&amp;gt;);ConCurrent Feature (동시성 기능)동시성리엑트는 항상 동시성을 추구하고 있다.그러나 자바스크립트는 싱글 스레드기반 언어로 여러 작업을 동시에 처리할 수 없다.그래서 ConCurrent Mode를 사용해 동시에 작업이 처리되는 것처럼 기능들을 확대하고 있었다. 여러 작업을 작은 단위로 나눈 후 작업들 간의 우선순위를 정한다. 정해진 우선순위에 따라 작업을 수행한다.즉 실제로는 동시에 작업이 실행되지 않지만 사용자 입장에서는 작업 간 전환이 매우 빨라 동시에 작업이 진행되는 걸로 보인다.React v18 에서는 동시성을 기능으로 제공하기 위해서 긴급 업데이트와 긴급하지 않은 업데이트를 구분할 수 있는 개념을 추가했다.TransitionsUrgent updates 는 입력, 클릭, 누르기 등과 같은 직접적인 상호 작용을 반영 (ex. input 입력)Transition updates 는 UI를 한 보기에서 다른 보기로 전환 (ex. 검색 필터 변경)아래와 같이 startTransition을 사용해 타이핑, 클릭, 스크롤 등에서 쓰로틀링이나 디바운싱같은 처리 없이도 렌더링이 완료되기 전에 변경된 최신 결과만을 보여줄 수 있다.import { startTransition } from &quot;react&quot;;// 긴급: 입력한 내용 표시setInputValue(input);// 내부 상태 업데이트를 Transition으로 후순위로 넘김startTransition(() =&amp;gt; { // 쿼리 결과 표시 setSearchQuery(input);});startTransition에 래핑된 업데이트는 긴급하지 않은 것으로 처리되며 클릭이나 키 누름과 같은 더 긴급한 업데이트가 들어오는 경우 중단된다.전환이 사용자에 의해 중단되면(예: 여러 문자를 연속으로 입력) React는 다음을 throw하고, 완료되지 않은 오래된 렌더링 작업을 제거하고 최신 업데이트만 렌더링된다.transition은 hook 형태와 API 형태가 있는데 사용용도는 다음과 같다. useTransition: 보류 상태를 추적하는 값을 포함하여 전환을 시작하는 훅 startTransition: 후크를 사용할 수 없을 때 트랜지션을 시작하는 방식쉽게말해 useTransition은 지금 순위가 낮은 업데이트가 보류중인지 여부를 알려주는 값을 포함한 훅이다.useTransition 사용법import { useTransition } from &quot;react&quot;;function App() { // 지연 시간을 초기화 할 수 있다. const [isPending, startTranstion] = useTransition({ timeoutMs: 1000 }); function updateSearchQuery(e) { useTransition(() =&amp;gt; { // 쿼리 결과 표시 setSearchQuery(e.event.value); }); } return &amp;lt;div id=&quot;app&quot;&amp;gt;{isPending &amp;amp;&amp;amp; &amp;lt;p&amp;gt;Current Updating...&amp;lt;/p&amp;gt;}&amp;lt;/div&amp;gt;;}useDeferredValue위에 useTranstion과 동일하다고 볼 수 있는 기능이다.긴급하지 않은 부분이 다시 렌더링하는 것을 연기할 수 있으며, 어찌 보면 디바운싱과 같지만 고정된 시간 지연이 없어서 React는 첫 번째 렌더링을 진행한 후에 지연된 렌더링을 시도한다.useTrnasaction과 가장 큰 차이는 useTransaction은 상태를 업데이트하는 코드를 래핑하는 반면에 useDeferredValue는 상태를 업데이트하면서 영향 받는 값들을 래핑한다.아래와 같이 사용할 수 있다.function ProductList({ products }) { const deferredProducts = useDeferredValue(products); return ( &amp;lt;ul&amp;gt; {deferredProducts.map((product) =&amp;gt; ( &amp;lt;li&amp;gt;{product}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; );}useSyncExternalStore아래에 훅이 나온 배경을 설명하기 전에 낯설 수 있는 단어를 먼저 설명하려고 한다.Extarnal Store외부 저장소는 subscribe할 수 있는 모든 것이다. (Redux, 전역 변수, 모듈 범위 변수, DOM 상태 등)Internal Store내부 저장소에는 props, context, useState, useReducer가 포함된다.React v18 부터는 동시성 렌더링을 반영하면서 Tearing이란 문제가 일어나기 시작했다.Tearing은 시각적인 불일치를 나타내며, UI가 동일한 상태에 대해서 여러 값을 표시하는 것을 의미한다.React v18부터 렌더링을 중지하기 때문에 일시 정지 사이에 업데이트는 렌더링에 사용되는 데이터와 관련된 변경사항을 가져올 수 있다.동기 렌더링에서는 아래와 같이 UI는 일관성을 유지할 수 있었다.아래에 동시 렌더링 시에는 처음에 파란색이였다가. React에서 외부 스토어가 변경되어 빨간색으로 렌더링을 계속하면서 Tearing을 유발한다.위와 같은 이유로 useExternalStore hook을 사용해 스토어 내에 데이터를 올바르게 가져올 수 있도록 한다.useSyncExternal 훅은 두 가지 기능을 사용할 수 있다. subscribe - 콜백 함수를 등록하는 함수 getSnapshot - subscribe 된 값이 마지막 렌더링 이후 변경되었는지 렌더링 되었는지 확인하고, 문자열이나 숫자같은 변경할 수 없는 값이거나 캐싱된 객체인지 확인하여 immutable한 값이 반환된다.import {useSyncExternalStore} from &#39;react&#39;; or// Backwards compatible shimimport {useSyncExternalStore} from &#39;use-sync-external-store/shim&#39;;//Basic usage. getSnapshot must return a cached/memoized resultuseSyncExternalStore( subscribe: (callback) =&amp;gt; Unsubscribe getSnapshot: () =&amp;gt; State) =&amp;gt; State// Selecting a specific field using an inline getSnapshotconst selectedField = useSyncExternalStore(store.subscribe, () =&amp;gt; store.getSnapshot().selectedField);getSnapshotimport { useSyncExternalStoreWithSelector } from &quot;use-sync-external-store/with-selector&quot;;const selection = useSyncExternalStoreWithSelector( store.subscribe, store.getSnapshot, getServerSnapshot, selector, isEqual);Suspense FeaturesReact v16.6 버전부터 Suspense로 로드 상태를 명시적으로 지정할 수 있었다.하지만 React.lazy를 이용한 분할 코드였고, 서버에서 렌더링할 때에는 사용할 수 없었다.그래서 React v18부터는 Suspense를 확장하여 비동기 작업(로드 코드, 데이터, 이미지 등)을 처리할 수 있도록 변경되었다.아래와 같은 코드로 사용할 수 있으며 작업중에는 fallback 파라미터로 넘기는 엘리먼트가 표시된다.&amp;lt;div&amp;gt; {showComments &amp;amp;&amp;amp; ( &amp;lt;Suspense fallback={&amp;lt;Spinner /&amp;gt;}&amp;gt; &amp;lt;Panel&amp;gt; &amp;lt;Comments /&amp;gt; &amp;lt;/Panel&amp;gt; &amp;lt;/Suspense&amp;gt; )}&amp;lt;/div&amp;gt;useIduseId는 클라이언트와 서버측에서 모두 고유한 id를 생성하는데 사용할 수 있으며아래와 같은 형태로 사용할 수 있다.function Checkbox() { const id = useId(); return ( &amp;lt;&amp;gt; &amp;lt;label htmlFor={id}&amp;gt;Do you like React?&amp;lt;/label&amp;gt; &amp;lt;input id={id} type=&quot;checkbox&quot; name=&quot;react&quot; /&amp;gt; &amp;lt;/&amp;gt; );}useInsertionEffectuseEffect와 동일하지만 DOM이 변경 후 그리고 레이아웃 전에 동기적으로 실행되는 훅이다. 레이아웃을 읽기 전에 스타일을 DOM에 삽입하려면 해당 훅을 사용하면 된다.레이아웃 전이기 때문에 ref로 엘리먼트에 액세스할 수 없다.useInsertEffect는 CSS-in-JS 렌더링 도중 스타일을 삽입할 때 생기는 성능 문제를 해결하는 용도이다.function useCSS(rule) { useInsertionEffect(() =&amp;gt; { if (!isInserted.has(rule)) { isInserted.add(rule); document.head.appendChild(getStyleForRule(rule)); } }); return rule;}function App() { let className = useCSS(rule); return &amp;lt;div className={className} /&amp;gt;;}" }, { "title": "프론트 엔드에서의 렌더링 최적화", "url": "/posts/post23/", "categories": "CS, Web", "tags": "Web, 렌더링 최적화, 최적화", "date": "2022-07-28 00:00:00 +0900", "snippet": "1. 트리쉐이킹NextJs 웹 어플리케이션 최적화 (트리셰이킹) 포스팅에서 설명처럼 사용하지 않는 모듈들을 제거하여 실제로 사용하는 모듈만을 남겨 파일의 크기를 줄이는 방식이다.2. 블록 리소스 최적하DOM (Document Object Model) 과 브라우저 렌더링 이 포스팅에서 설명했듯이 HTML 파싱을 차단하는 블록 리소스를 태그의 위치를 적절히 설정하여 최적하 하는 방법이다.페인팅을 빠르게 하고 로딩 속도를 개선할 수 있다.3. 이미지 스프라이트 / 지연로딩이미지 스프라이트이미지 스프라이트는 여러 개의 이미지를 하나로 합쳐서 관리하는 기법이다.이미지가 많을 경우 웹 브라우저는 서버에 해당 이미지의 수만큼 요청해야만 하기 때문에 웹 페이지의 로딩 시간이 오래 걸릴 수 밖에 없다.그래서 위와 같이 한 이미지에 여러 이미지를 배치하고, 포지션별로 이미지를 구분해 한번의 로딩만으로 여러 이미지를 사용하는 기법이다.이미지 지연로딩여러 이미지가 보이는 페이지에서, 사용자 화면에 보이는 이미지만을 로드하고, 아직 보지 못하는 이미지(스크롤 되지 않은 이미지)들은 바로 요청하지 않는 기법강제 동기 레이아웃 및 스래싱 피하기강제 동기 레이아웃 지양하기일반적으로 javascript가 실행된 다음 스타일 계산, 레이아웃이 실행된다. 그러나 javascript를 사용해 브라우저가 레이아웃을 더 일찍 수행할 수 있도록 할 수 있다.스타일을 변경한 후 offsetHeight, offsetTop과 같은 계산된 값을 속성으로 읽으면 강제로 동기 레이아웃이 실행된다.// not goodfunction getBoxHeight() { box.classList.add(&quot;getbox&quot;); console.log(box.offsetHeight);}// goodfunction getBoxHeight() { console.log(box.offsetHeight); box.classList.add(&quot;getbox&quot;);}위와 같은 경우 높이 가져오기 위해 레이아웃을 실행한 후 가져와야 한다. 이거는 불필요하고 잠재적으로 비용이 많이 드는 작업이다. 항상 스타일을 읽는 것을 일괄 처리한 후에 수행해야 한다.레이아웃 스래싱많은 레이아웃을 연속적으로 빠르게 수행하는 것을 레이아웃 스래싱이라고 한다.function resizeAllParagraphsToMatchBlockWidth() { for (var i = 0; i &amp;lt; paragraphs.length; i++) { paragraphs[i].style.width = box.offsetWidth + &quot;px&quot;; }}위에 소스는 루프의 각 반복에서 스타일 값을 읽고 너비를 업데이트하게 되면 매번 다음 반복에서 전에 요청된 스타일로 변경되어야 하기 때문에 레이아웃에 계속되서 실행된다.let width = box.offsetWidth;function resizeAllParagraphsToMatchBlockWidth() { for (var i = 0; i &amp;lt; paragraphs.length; i++) { paragraphs[i].style.width = width + &quot;px&quot;; }}위에 소스처럼 한번의 값을 읽어 변수에 할당하여 사용하는 것이 좋다." }, { "title": "NextJs 웹 어플리케이션 최적화 (트리셰이킹)", "url": "/posts/post22/", "categories": "Web, NextJs", "tags": "Web, NextJS, Webpack, TreeShaking, 최적화", "date": "2022-07-04 00:00:00 +0900", "snippet": "Tree ShakingTree Shaking은 실제로 사용하는 모듈만 로딩하게 하여 번들의 사이즈를 줄여빌드 시간과 렌더링 시간감소를 기대할 수 있다.bundle-analyzer을 통해 번들 크기 시각화 @next/bundle/analyzerNextJs에선 위의 패키지를 통해 빌드 프로세스에서 번들링 된 패키지 크기를 시각화 하여 볼 수 있다. webpack-bundle-analyzerNextJS가 아닌 Webpack을 집적 구성해 프로젝트를 빌드할 때는 위의 패키지를 사용해 동일한 결과를 가질 수 있다.번들 사이즈 측정먼저 @next/bundle-analyzer를 사용하기 위해서는 next.config.js 파일에 bundle analyzer를 intergrate 해주어야 한다.nextconfig.jsconst withBundleAnalyzer = require(&quot;@next/bundle-analyzer&quot;)({ enabled: process.env.ANALYZE === &quot;true&quot;,});module.exports = withBundleAnalyzer(nextConfig);실행은 아래와 같이 package.json 파일에 스크립트로 설정하거나 .env 파일로 설정하여 실행하면 된다.package.json&quot;analyze&quot; : &quot;cross-env ANALYZE=true next build&quot;위와 같이 실행 후에는 빌드 결과물의 .next 폴더 아래에 analyze 폴더에서 확인할 수 있다.그리고 해당 파일을 누르면 아래와 같은 결과들을 확인할 수 있다. 사이즈를 표시하는 속성으로 stat과 parsed, Gzipped을 확인할 수 있다. stat은 축소와 같은 변환 이전의 파일의 ‘입력’크기 이고,parsed는 파일의 ‘출력’ 크기 이며, Webpack이 트리셰이킹을 마친 상태의 크기다. gzip은 압축을 통해 구문 분석된 번들/모듈을 실행하는 크기이다. 우리는 parsed size만을 보면된다.작업 진행가장 큰 번들의 크기가 aws-sdk의 2.69MB이다.S3를 사용하기 위한 모듈이였는데 EC2, utils 등의 여러 모듈도 함께 빌드되어 가장 큰 용량을 차지하는 것으로 보인다.각자 사용하는 모듈이 다르고 모듈마다 트리셰이킹 방식도 다르기 때문에 이번 포스팅에선 가장 큰 패키지 하나만 진행하려고한다.변경 전import { config, S3 } from &quot;aws-sdk&quot;;const region = &quot;ap-northeast-2&quot;;const bucket = &quot;blockjobsawsbucket&quot;;config.update({ region: region, accessKeyId: process.env.NEXT_PUBLIC_AWS_ACCESS_ID, secretAccessKey: process.env.NEXT_PUBLIC_AWS_ACCESS_KEY,});const handleFileInput = async (e: ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { const file = e.target.files?.[0]; const upload = new S3.ManagedUpload({ params: { Bucket: bucket, // 버킷 이름 Key: id + &quot;.png&quot;, // 유저 아이디 혹은 enterpriseid Body: file, // 파일 객체 }, }); const promise = upload.promise(); promise.then( function () { // 종료를 상위 컴포넌트에 callback uploadComplete(); }, function (err) { // 이미지 업로드 실패 console.log(err); } );}; aws-sdk 패키지를 제거한 후 S3 업로드에 필요한 @aws-sdk/client-s3 @aws-sdk/lib-storage 패키지를 다운받아해당 패키지에 맞게 코드를 수정했다.변경 후import { S3Client } from &quot;@aws-sdk/client-s3&quot;;import { Upload } from &quot;@aws-sdk/lib-storage&quot;;export const useS3 = () =&amp;gt; { const region = &quot;ap-northeast-2&quot;; const bucket = &quot;blockjobsawsbucket&quot;; const fileBaseUrl = `https://${bucket}.s3.${region}.amazonaws.com/`; const handleFileInput = async ({ id, uploadComplete, e, }: ProfileUpload_props) =&amp;gt; { const file = e.target.files?.[0]; const s3 = new S3Client({ region: region, credentials: { accessKeyId: process.env.NEXT_PUBLIC_AWS_ACCESS_ID ?? &quot;&quot;, secretAccessKey: process.env.NEXT_PUBLIC_AWS_ACCESS_KEY ?? &quot;&quot;, }, }); try { const mulitpartUpload = new Upload({ client: s3, params: { Bucket: bucket, // 버킷 이름 Key: id + &quot;.png&quot;, // 유저 아이디 혹은 enterpriseid Body: file, // 파일 객체 }, }); await mulitpartUpload.done(); await uploadComplete(id); } catch (e) { console.log(e); } }; return { handleFileInput, fileBaseUrl };};작업 결과위와같이 작업을 진행한 결과 Parsed Szie: 2.69MB -&amp;gt; 373.61KB (-86%)사실 위와 같은 결과는 나오기 쉽지 않고 (사실 나오면 안된다. 큰 모듈을 통째로 사용하는 것을 지양해야 한다.) 10% ~ 20%의 감소정도를 기대해 볼 수 있는 것 같다. (실무 프로젝트에서도 최대가 15% 정도 였다…)" }, { "title": "NextJs Environment Variable (환경변수) 설정하기", "url": "/posts/post21/", "categories": "Web, NextJs", "tags": "Web, NextJS, React, TypeScript", "date": "2022-06-08 00:00:00 +0900", "snippet": "NextJs Environmnet VariableNextJs에선 .env.local을 통해 로드 된 모든 환경변수를 사용할 수 있다..env.localDB_HOST=localhostDB_USER=rootDB_PASS=1234위와 같이 설정하고 사용하려는데 계속 undefined가 표시되더라 그래서 NextJS 공식 문서를 다시 살펴보니기본적으로 환경 변수는 Node.js 환경에서만 사용 가능이라 되어있더라, 그래서 getStaticProps 같이 브라우저 렌더링 전에 로드하는건 되고, jsx에서 가져오려니 안되는 것이였다.방법은 변수에 NEXT_PUBLIC_접두사를 붙여주면 브라우저 Javascript에 인라인되어 사용할 수 있다..env.loca (수정 후)NEXT_PUBLIC_DB_HOST=localhostNEXT_PUBLIC_DB_USER=rootNEXT_PUBLIC_DB_PASS=1234" }, { "title": "IPFS", "url": "/posts/post20/", "categories": "BlockChain, 개념", "tags": "BlockChain, 개념, IPFS", "date": "2022-06-03 00:00:00 +0900", "snippet": "여담BlockReview라는 프로젝트를 진행하면서 리뷰를 NFT화 하는 Contract를 만들었는데 NFT를 저장할 때 통상 IPFS라는 시스템에 저장하게 되더라 일반 URL 저장과 무엇이 다른지 한 번 정리해보려고한다.IPFS공식 문서에서는 IPFS는 파일, 웹 사이트, 응용 프로그램 및 데이터를 저장하고 액세스 하기 위한 분산 시스템이란다.먼저 IPFS의 특징을 알아보자, P2P 분산 파일 시스템 (탈중앙화) IPFS 노드에 참여하게되면 FileCoin이란 인센티브를 제공한다. HTTP는 URL을 통해 접근하지만, IPFS는 내용으로 접근하게된다.P2P 분산 파일 시스템 (탈 중앙화)예를 들어, Aard를 위키피디아 주소로 접근할 수 있다.이것을 ipfs를 통해 접근하게되면, IPFS로 접근하게되면, 전 세계 IPFS 노드에게 요청을하여 페이지를 공유한다.이러한 방식을 가져가며 얻는 이익은 아래와 같다. 서버가 공격을 받거나, 서버에 이상이 생겨도 다른 곳에서 동일한 웹 페이지를 얻을 수 있게 된다. 콘텐츠를 검열하기 쉽지 않다. IPFS의 파일은 요청을 받는 곳을 예상하기 힘들기 때문에 행동을 제약하기 쉽지않다. 토렌트와 같은 불법 다운로드도 위와 같은 이유로 잡아내기 쉽지 않다. 서버가 굉장히 멀리있어도, 가까이 있는 노드가 있다면 속도를 높여 빨리 가져올 수 있다. 요즘은 이것을 일반 서비스에선 CDN으로 해결한다 인센티브 (FileCoin)IFPS의 클라이언트는 특정 수준의 중복성 및 가용성으로 데이터를 저장하기 위해 비용을 지불하고, 스토리지 제공자는 데이터를 지속적으로 저장하고, 마치 비트코인의 pow 처럼 데이터에 대한 증명을 함으로써 FileCoin을 얻게된다.콘텐츠 주소 지장IPFS는 HTTP 계층에서 콘텐츠 주소 지정을 사용한다. 파일의 내용을 가져와서 암호화 해시를 적용해 주소를 만들게 된다 그래서 https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Aardvark.html 같은 형태의 주소가 만들어진다." }, { "title": "블록체인의 채굴", "url": "/posts/post19/", "categories": "BlockChain, 개념", "tags": "BlockChain, BitCoin, POW, POS", "date": "2022-05-25 00:00:00 +0900", "snippet": "블록체인의 채굴블록체인에서의 &#39;채굴&#39; 이라는 단어는 사실 우리 사회적으로 통용되는 귀금속의 &#39;채굴&#39;과 비슷한 부분이 있지만, 엄연히 따지면 다르다.블록체인의 채굴의 주된 목적은 보상금이나 새로운 코인의 생성이 아니다.코인은 그저 블록체인에서 채굴 프로세스에 대한 인센티브일 뿐이다. 블록 생성의 보상으로 채굴자에게 주는 코인은 채굴자들이 네트워크 보안을 지켜주고, 동시에 통화 공급을 실행하게 하는 동기를 부여한다. 하지만, 오늘 날 많은 사람들이 블록체인 채굴의 목적 자체가 코인을 목적으로 잘못 판단하고 있다.채굴은 분산화된 클리어링 하우스의 주요 프로세스로, 채굴에 의해 거래를 검증 및 승인한다.채굴은 비트코인 체제의 보안을 강화시켜 주고 중앙 권력기관 없이도 네트워크 전역에서 합의가 이루어질 수 있도록 해준다.짧게 말한다면 비트코인의 보안이 분산화 되는 매커니즘라고 정리할 수 있다.채굴일어나고 블록체인에 적용되는 과정은 아래와 같다. 검증된 비트코인 거래들이 거래풀에 쌓이게 된다. 채굴자들이 경쟁하여 가장먼저 Pow을 성공한 사람이 블록 생성자가 된다. 블록이 생성되고 거래풀에 쌓인 거래들이 추가(승인)되어 블록체인 내에 추가된다. 채굴자는 블록을 생성하면서 블록 내에 포함되는 거래들에 대한 수수료와 새로운 코인을 생성하며 코인에 대한 인센티브를 받게된다.거래 풀 (Memory pool)비트코인 네트워크 상에 있는 거의 대부분의 노드들이 거래 풀이라 불리는 미승인 거래로 이루어진 임시 목록을 보관하고 있다.노드들은 이풀을 이용해서 네트워크에는 알려졌지만, 블록체인에 아직 포함되지 않은 거래들을 추적할 수 있게 된다.새로운 블록이 생성될 시에 수수료가 많은 것으로 우선순위를 정해 블록체인 내에 포함되게 된다.작업증명 (Pow, Proof of Work)채굴을 하기 위해서는 암호화 해시 알고리즘을 기반으로 하는 어려운 수학 문제를 풀어야 된다.이 수학 문제에 대한 해답을 작업증명 이라고 한다.암호 해시 알고리즘은 입력값으로 출력값을 유추하는 것이 사실상 불가능하기 때문에 특정 목표에 일치하는 해시결과를 얻기 위해서는 무작위로 해싱하여 결과가 우연히 나타날 때까지 입력값을 임의로 수정해 가는 수 밖에 없다.이 임의로 수정하는 변수로 사용되는 숫자 값을 난스(nonce)라고 한다.목표값이 0으로 시작되는 해시라고 가정해보자 16진수(0부터 F)까지 16개의 진수 중 하나로 가능성으로 얘기한다면, 한다면 평균 16회 정도의 해싱으로 결과를 만들어 낼 수 있다고 볼 수 있다.이렇게 목표값이 부여한 난이도로부터 성공하기 위해 필요한 작업량을 추정할 수 있다. 입력값 자체는 목표값 아래의 결과를 내기 위해서 행해져야 하는 작업의 특정량에 대한 증명이 된다. 그래서 작업증명이라는 것이다.비트코인의 공급량비트코인의 통화 공급은 채굴을 통해서 이루어지며, 약 4년마다(정확히 210,000 블록)마다 절반으로 줄어든다.2009년 50비트코인으로 시작됐으며, 2022년 현재로선 6.25 비트코인으로 줄어들었다.이 계산으론 2140년이 되면 비트코인의 총량인 2099만 9999.98 비트코인이 발행된다.한정된 양을 한도로 통화가 점점 줄어들면서 발행되게 되면 자연스럽게 통화를 발행하면서 생기는 인플레이션은 방지가 된다.하지만, 해당 통화는 디플레이션을 야기할 수 도 있다. 하지만, 일반 통화는 수요의 붕괴로 인해 디플레이션이 이러나게 되지만, 비트코인은 예상 가능한 제공 공급량에 의해 발생하는 디플레이션이기 때문에 비트코인 전문가들은 디플레이션 자체가 나쁜 것은 아니라 평 하고있다." }, { "title": "NextJs에서 Web3 (MetaMask, ConnectWallet) 연결 구현하기 - with ethers.js / web3Modal", "url": "/posts/post18/", "categories": "BlockChain, Ethereum", "tags": "BlockChain, Ethereum, NextJS, ethers.js", "date": "2022-05-18 00:00:00 +0900", "snippet": "라이브러리3개의 라이브러리를 다운받는다. recoil - 지갑의 address와 provider 등을 status 에 저장하기 위해서ethers.js - Ethereum 블록체인을 JavaScript로 상호작용할 수 있게 해주는 라이브러리이다.web3modal - WalletConnect, MetaMask 등의 여러 지갑을 dapp에서 한 가지 형식으로 통합하여 사용할 수 있는 라이브러리이다.recoilnpm install recoilethersnpm i ethersweb3-modalnpm install --save web3modalWeb3 정보를 저장할 type 생성먼저 Type들과 web3 정보를 저장할 atom을 생성해준다.types/web3.tsinterface Web3_Model { address: string | null | undefined; network: ethers.providers.Network | null | undefined;}export const initialWeb3 = atom&amp;lt;Web3_Model&amp;gt;({ key: &quot;my_web3&quot;, default: { network: null, address: null, },});Web3Cleint Hooks 생성나 같은 경우엔 여러 컴포넌트에서 편하게 사용할 수 있게 hook으로 만들어서 사용하게 되었다.web3modal 설정이미 infura를 사용한 적이 있는 사람은 접속하여 InfuraId를 복사 붙여넣기 하면 된다.새 계정인 경우엔 CREATE NEW PROJECT 탭으로 이동해 프로젝트를 생성하고 해당 프로젝트의 세팅 화면에서 자신이 사용할 네트워크의 infuraId를 가져오면 된다.아래 사진의 빨간 표시 부분이다.그리고 아래 소스와 같이 option을 세팅하고 web3Modal을 초기화 해준다.나같은 경우엔 Ropsten 네트워크를 사용하기 위해 설정했고, 경우에 따라 network를 변경해주면된다.const providerOptions = { walletconnect: { package: WalletConnectProvider, options: { infuraId: process.env.INFURA_PUBLIC_ID, }, },};let web3Modal: Web3Modal | null;if (typeof window !== &quot;undefined&quot;) { web3Modal = new Web3Modal({ network: &quot;Ropsten&quot;, cacheProvider: true, providerOptions, });}state먼저, 아까 맨 처음에 구성한 recoil atom을 먼저 세팅해주었다.modalprovider와 web3Provider을 recoil로 관리하지 않은 이유는 아래 소스의 반환 값들이 readonly라 state로 정의가 불가능하다고 오류가 떴다;; 정확한 이유는 모르겠다 ㅠㅠ 개발 중에 수정이 가능하면 수정할 생각이다.const [web3State, SetWeb3] = useRecoilState&amp;lt;Web3_Model&amp;gt;(initialWeb3);// eslint-disable-next-line @typescript-eslint/no-explicit-anyconst [modalProvider, SetModalProvider] = useState&amp;lt;any&amp;gt;(null);const [web3Provider, SetWeb3Provider] = useState&amp;lt;ethers.providers.Web3Provider | null&amp;gt;(null);web3 connectweb3을 연결하는 부분은 아래 소스와 같다.web3modal로 먼저 지갑 계정을 연결한 뒤 반환 받은 provider을 ethers.js provider에 주입하는 방식이다.나는 connect를 하면서 바로 연결된 계정을 통해 contract를 실행시키기 위해 아래와 같이 Contract를 초기화 하여 반환해주었다.toast와같은 component로 지갑의 변경을 표시해주는 것도 좋은 방법이다.const connect = useCallback(async () =&amp;gt; { if (web3Modal) { try { const provider = await web3Modal.connect(); const web3Provider = new ethers.providers.Web3Provider(provider); const signer = web3Provider?.getSigner(); const address = await signer.getAddress(); const network = await web3Provider?.getNetwork(); const ConnWeb3: Web3_Model = { address: address, network: network, }; const Contract = new ethers.Contract( Contract_Address, BlockJobs_ABI, signer ); return Contract; } catch (e) { console.log(&quot;web3 connection error&quot;, e); } } else { }}, []);web3 disconnectdisconnection는 특별한 것 없이 modalProvider의 disconnect함수를 사용하고 recoil의 atom을 초기화 시켜주었다.const disconnect = useCallback(async () =&amp;gt; { if (web3Modal) { web3Modal.clearCachedProvider(); if (modalProvider) { await modalProvider.disconnect(); } const DisConn: Web3_Model = { address: null, network: null, }; SetWeb3(DisConn); } else { console.error(&quot;No Web3Modal&quot;); }}, []);web3 changedmodalProvider가 연결되어있을 때 지갑이나 네트워크가 변경되었을 때를 확인하는 changed 이벤트 들을 정의해 두었다.useEffect(() =&amp;gt; { if (modalProvider?.on) { const handleAccountsChanged = (accounts: string[]) =&amp;gt; { SetWeb3({ ...web3State, address: accounts[0] }); }; const handleChainChanged = (_hexChainId: string) =&amp;gt; { if (typeof window !== &quot;undefined&quot;) { console.log(&quot;switched to chain...&quot;, _hexChainId); window.location.reload(); } else { console.log(&quot;window is undefined&quot;); } }; const handleDisconnect = (error: { code: number; message: string }) =&amp;gt; { // eslint-disable-next-line no-console console.log(&quot;disconnect&quot;, error); disconnect(); }; modalProvider.on(&quot;accountsChanged&quot;, handleAccountsChanged); modalProvider.on(&quot;chainChanged&quot;, handleChainChanged); modalProvider.on(&quot;disconnect&quot;, handleDisconnect); return () =&amp;gt; { if (modalProvider.removeListener) { modalProvider.removeListener(&quot;accountsChanged&quot;, handleAccountsChanged); modalProvider.removeListener(&quot;chainChanged&quot;, handleChainChanged); modalProvider.removeListener(&quot;disconnect&quot;, handleDisconnect); } }; }}, [web3Provider, disconnect]);useWeb3Client이제 위에 정의한 모든 소스를 아래처럼 주입하여 훅으로 사용할 수 있다!const useWeb3Client = () =&amp;gt; { //위에 정의한 소스 return { connect, disconnect, };};" }, { "title": "블록체인 SideChain", "url": "/posts/post17/", "categories": "BlockChain, 개념", "tags": "BlockChain, SideChain", "date": "2022-05-17 00:00:00 +0900", "snippet": "SideChain먼저, 사이드 체인이 나오게 된 배경은 비트코인의 여러가지 한계점 때문에 나오게 되었다. 느린 처리 속도 - 약 10분의 블록 생성 시간으로 인해 자신의 거래가 블록체인에 기록되어 있는지 확인하려면 몇 초에서 느리면 수십분까지 기다리게 된다. 하나의 거래방식 - 비트코인 네트워크에선 오직 비트코인 만을 거래할 수 있다. 공개 방식 - 비트코인은 퍼블릭 블록체인으로 모든 거래가 공개되어 기밀성을 지킬 수 없다. 이 외에도 다른 문제들도 가지고 있지만 사이드 체인과 관련해서는 이 두 가지만 생각하고 얘기해도 될 것 같다.사이드 체인은 양항뱡 페그를 이용해 서로 다른 블록체인을 연결하는 별도의 블록체인 네트워크이다.블록체인끼리 서로 상호 운용할 수 있게 된다는 것 이다.Side Chain작동 원리 어떤 유저가 Main Chain에서 자신의 코인을 특정 address(동결 주소)로 송금하게 되면 그 코인에 대해서 권한을 잃게되며, 그 코인만큼의 자산을 이용할 수 없게된다. 일정 시간이 지나 체인이 검증되면 같은 양의 대체코인 (다시 비트코인으로 바꿀 수도 있으니 비트코인이라 봐도 무방하다)이 Side Chain에서 발행되게 된다. Side Chain에서 생성된 코인으로 다른 블록체인 코인이나 다른 대체코인과 거래할 수 있게 된다. Side Chain의 확장성위에서 얘기한 Side Chain의 작동 원리는 코인의 거래만을 얘기했지만, Side Chain을 이용해 기존의 코인들에 단점을 대체할 수 있다.사이드 체인에 스마트 컨트랙트를 구축해 비트코인을 이더리움 네트워크에서 사용할 수 있다던가, 수수료를 적게 만드는 등 Side Chain으로 인해 기존의 코인의 단점들을 보안 해나갈 수 있다." }, { "title": "NextJs에 Chakra UI + Typescript (emotion) 적용", "url": "/posts/post16/", "categories": "Web, NextJs", "tags": "NextJs, Chakra, Emotion", "date": "2022-05-16 00:00:00 +0900", "snippet": "Chara UIReact나 NextJS 등에서 사용할 수 있는 Component Library이다.Emotion을 기반으로 만들어 졌으며, 제일 모던하고 CSS를 많이 사용하지 않아도 될 것 같고, styled-component로 구현했던 것 들은 Emotion으로 충분히 대체 가능하기 때문에 이번 프로젝트에서 styled-component를 걷어내고 사용하게 됐다.Installnpmnpm i @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^6yarnyarn add @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^6Theme / Global 적용나 같은 경우 먼저 global로 적용할 styles.ts 파일을 먼저 만들어줬다.styles.tsconst styles = { global: { &quot;html, body&quot;: { margin: 0, padding: 0, }, a: { textDecoration: &quot;none&quot;, }, &quot;*&quot;: { boxSizing: &quot;border-box&quot;, }, },};export default styles;그 다음으론 foundation으로 사용할 폰트, 컬러 등을 지정하였다.color 같은 경우는 charkra 모듈인 theme를 import하여 color를 지정하였다. index로 채도를 조절할 수 있어서 꽤나 요긴했다!다른 foundation 파일들은 생략하겠다. 코드가 너무 길어져서…colors.tsimport { theme } from &quot;@chakra-ui/react&quot;;const primary = theme.colors.teal;const secondery = theme.colors.gray;const blue = theme.colors.twitter;export default { primary, secondery, blue,};그리고 마지막으로 component의 기본 스타일을 지정하였다.아래가 Chakra UI의 Document에서 제공하는 component CustomStyle 포맷이다.const ComponentStyle = { // 객체의 기본 스타일 정의 baseStyle: {}, // 사이즈에 대한 스타일 정의 (&quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;) sizes: {}, // 시각적인 변수에 대한 스타일 정의 (&quot;outline&quot;, &quot;solid&quot;) variants: {}, // size와 variants에 대한 기본 값 정의 defaultProps: { size: &quot;&quot;, variant: &quot;&quot;, },};예로 아래와 같이 꾸밀 수 있겠다.button.tsconst Button = { baseStyle: { fontWeight: &quot;bold&quot;, }, sizes: { xl: { h: &quot;56px&quot;, fontSize: &quot;lg&quot;, }, }, variants: { solid: (props) =&amp;gt; ({ bg: props.colorMode === &quot;dark&quot; ? &quot;red.300&quot; : &quot;red.500&quot;, }), },};export default Button;이렇게 나는 크게 Global Foundations Components 구조로 theme를 정의했다.그럼 이제 CharkProvider에 적용시키기 위한 index.ts가 필요하다.아래와 같이 필요한 스타일들을 module화 한 뒤 import하여 extendTheme로 export한다.index.tsimport { extendTheme } from &quot;@chakra-ui/react&quot;;// Global style overridesimport styles from &quot;./styles&quot;;// Foundational style overridesimport config from &quot;./foundations/config&quot;;import fonts from &quot;./foundations/fonts&quot;;import colors from &quot;./foundations/colors&quot;;import shadows from &quot;./foundations/shadows&quot;;// Component style overridesimport Button from &quot;./components/button&quot;;const customTheme = { styles, fonts, config, colors, shadows, components: { Button, },};export default extendTheme(customTheme);이제 export한 theme를 _app.tsx 파일에 Provider 시켜주면 된다._app.tsximport { ChakraProvider } from &quot;@chakra-ui/react&quot;;import themes from &quot;themes&quot;;function MyApp({ Component, pageProps }: AppProps) { return ( &amp;lt;&amp;gt; &amp;lt;ChakraProvider resetCSS theme={themes}&amp;gt; &amp;lt;Component {...pageProps} /&amp;gt; &amp;lt;/ChakraProvider&amp;gt; &amp;lt;/&amp;gt; );}export default MyApp;이제 theme를 정의 한대로 잘 적용되는 것을 볼 수 있다!그리고 위에 style을 정의할 때 [h, bg] 같이 모르는 style 속성들이 있는데 이건 Chakra 내에서 사용하는 약식 정의다.링크를 타고 가 확인할 수 있다.ex) h -&amp;gt; height, bg -&amp;gt; background" }, { "title": "NestJs 순환 종속성", "url": "/posts/post15/", "categories": "BackEnd, NestJs", "tags": "nestjs, DI, error", "date": "2022-05-13 00:00:00 +0900", "snippet": "순환 종속성 오류 (circular dependency error)프로젝트에서 JWT 인증 Gaurd 구현을 위해서 UserModule에선 AuthModule를 import하고 Auth에선 UserMoudle을 import 하고있었다.그런데 module에서 분명히 import되어 있는데 inject이 비어있다는 거다? 그래서 자세히 살펴보니아래와 같은 설명이 되어있더라. A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency이게 무슨 뜻인가 하면 두 클래스가 서로 종속되는 관계일 때 순환 종속성 이 발생할 수 있다는 거다.Nest는 순방향 참조를 기본으로 하기 때문에 AuthModule &amp;lt;-&amp;gt; UserModule 이런 상태인 경우엔 Inject 혹은 import 할 때 따로 처리를 해줘야 한다는 말이다.Solution아래와 같이 서로 종속되는 module 파일에서 import 시에 forwardRef()함수로 참조시켜주면 해결된다.@Module({ imports: [forwardRef(() =&amp;gt; UserModule)],})export class AuthenticationModule {}" }, { "title": "Smart Contract으로 ERC-20 토큰 만들기 (OpenZepplin ERC20 소스분석)", "url": "/posts/post14/", "categories": "BlockChain, Solidity", "tags": "React, Solidity, Smart Contarct, Ethereum", "date": "2022-05-10 00:00:00 +0900", "snippet": "ERC-20ERC-20(Ethereum Request for Commnet 20)은 EIP(Ethereum Improvement Propasls)에서 관리하는 공식 프로토콜 중 하나로 Ethereum네트워크에서 유통 가능한 토큰의 표준이다. 요약하자면, 우리가 흔히 부르는 암호화폐 또는 코인이 여기에 해당된다.Contract 작성 전에제일 먼저 이전에 포스팅 한 Remix로 Solidity 로컬 개발 환경 만들기을 읽고 해당 개발환경을 갖추고 오길 바란다. 이 글은 해당 환경에서 진행된다.그다음으론 OpenZepplin을 이용해 ERC20 SmartContract을 구현할 것이다.그러니 OpenZepplin을 npm을 통해 다운받아주자npm install @openzeppelin/cli그 다음으론 rinkeby 테스트 넷에서 배포 후 테스트 해볼 것이기 때문에 rinkeby faucet 사이트에 들어가서 test ether를 받는다.이 사이트에 들어가서 본인이 사용하는 지갑의 주소를 넣어주면 된다. (참고로 잘 안준다… 열심히 노가다 해야된다.) https://faucet.rinkeby.io/ https://faucets.chain.link/rinkeby https://rinkebyfaucet.com/자 이제 준비는 다 됐다! Smart Contract를 작성해보자ERC20 토큰 소스 분석배포하는 토큰을 잘 사용하기 위해선 ERC20의 소스를 살펴볼 필요가 있다.ERC20.sol// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)pragma solidity ^0.8.0;import &quot;./IERC20.sol&quot;;import &quot;./extensions/IERC20Metadata.sol&quot;;import &quot;../../utils/Context.sol&quot;;contract ERC20 is Context, IERC20, IERC20Metadata { mapping(address =&amp;gt; uint256) private _balances; mapping(address =&amp;gt; mapping(address =&amp;gt; uint256)) private _allowances; uint256 private _totalSupply; string private _name; string private _symbol; constructor(string memory name_, string memory symbol_) { _name = name_; _symbol = symbol_; } function name() public view virtual override returns (string memory) { return _name; } function symbol() public view virtual override returns (string memory) { return _symbol; } function decimals() public view virtual override returns (uint8) { return 18; } function totalSupply() public view virtual override returns (uint256) { return _totalSupply; } function balanceOf(address account) public view virtual override returns (uint256) { return _balances[account]; } function transfer(address to, uint256 amount) public virtual override returns (bool) { address owner = _msgSender(); _transfer(owner, to, amount); return true; } function allowance(address owner, address spender) public view virtual override returns (uint256) { return _allowances[owner][spender]; } function approve(address spender, uint256 amount) public virtual override returns (bool) { address owner = _msgSender(); _approve(owner, spender, amount); return true; } function transferFrom( address from, address to, uint256 amount ) public virtual override returns (bool) { address spender = _msgSender(); _spendAllowance(from, spender, amount); _transfer(from, to, amount); return true; } function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { address owner = _msgSender(); _approve(owner, spender, allowance(owner, spender) + addedValue); return true; } function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) { address owner = _msgSender(); uint256 currentAllowance = allowance(owner, spender); require(currentAllowance &amp;gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;); unchecked { _approve(owner, spender, currentAllowance - subtractedValue); } return true; } function _transfer( address from, address to, uint256 amount ) internal virtual { require(from != address(0), &quot;ERC20: transfer from the zero address&quot;); require(to != address(0), &quot;ERC20: transfer to the zero address&quot;); _beforeTokenTransfer(from, to, amount); uint256 fromBalance = _balances[from]; require(fromBalance &amp;gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;); unchecked { _balances[from] = fromBalance - amount; } _balances[to] += amount; emit Transfer(from, to, amount); _afterTokenTransfer(from, to, amount); } function _mint(address account, uint256 amount) internal virtual { require(account != address(0), &quot;ERC20: mint to the zero address&quot;); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount); } function _burn(address account, uint256 amount) internal virtual { require(account != address(0), &quot;ERC20: burn from the zero address&quot;); _beforeTokenTransfer(account, address(0), amount); uint256 accountBalance = _balances[account]; require(accountBalance &amp;gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;); unchecked { _balances[account] = accountBalance - amount; } _totalSupply -= amount; emit Transfer(account, address(0), amount); _afterTokenTransfer(account, address(0), amount); } function _approve( address owner, address spender, uint256 amount ) internal virtual { require(owner != address(0), &quot;ERC20: approve from the zero address&quot;); require(spender != address(0), &quot;ERC20: approve to the zero address&quot;); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); } function _spendAllowance( address owner, address spender, uint256 amount ) internal virtual { uint256 currentAllowance = allowance(owner, spender); if (currentAllowance != type(uint256).max) { require(currentAllowance &amp;gt;= amount, &quot;ERC20: insufficient allowance&quot;); unchecked { _approve(owner, spender, currentAllowance - amount); } } } function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual {} function _afterTokenTransfer( address from, address to, uint256 amount ) internal virtual {}}함수를 하나씩 알아보자! 먼저 IERC20, IERC20metadata, Context 을 상속받고 있으며IERC20 인터페이스를 기반으로 만들어져 있다.변수 이름 설명 _balances 키값으로 주어지는 address 기준으로 해당 토큰 보유량을 반환하기 위한 매핑 변수이다. _allowances 키값으로 주어지는 다른 주소가 spender에게 approve한 토큰의 수를 확인하는 매핑 변수이다. _totalSupply 총 발행량 _name 토큰명 _symbol 토큰 심볼 (ex) ETH) Return 함수name토큰 이름을 반환한다.decimal기본값은 18이다. 이더리움은 단 wei이다 1Ether가 되기 위한 wei의 개수가 10^18이라기본값이 18로 되어있다.Gwei로 가스 비용을 표현하는데 0.00000~~1 이라 말하는거보다 1gwei이다 10gwei이다 이런식으로 환산해서 말하고 표현한다.보통 배포할 때 사용되며 필자는 deploy시에 (10 ** decimal)을 곱해 코드를 단순하게 사용한다. (송금 및 토큰 스왑시에도 사용할 수 있는 개념이다)totalSupply인자로 받은 주소의 토큰 보유량을 반환한다.allowancespender에게 승인해준 amount 값을 반환한다.Active 함수Approvespender에게 amount만큼의 토큰을 사용할 수 있게 승인해주는 함수다.보통 spneder는 SmartContact 주소가 들어가게된다.SmartContract에서 토큰을 사용하는 계약을 실행하기 전에 해주지 않으면 토큰을 송금할 수 없기 때문에 애꿎은 가스비만 날라가고 실행되지 않을 수 있다 꼭 실행해 줘야 한다.transferto 파라미터로 값의 주소로 amount 만큼의 송금을 실행한다.transferFromfrom에서 to로 amount의 송금을 실행하는 함수이다.이 함수는 SmartContract에서 발생시키기 때문에 실행 전에 from 주소에 대해 송금하는 amount 이상의 Approve를 받아야한다.일단 여기까지가 ERC-20의 표준 인터페이스를 구현한 함수들이다.(name,decimal은 제외아래로는 Openzepplin에서 제공하거나 확장 가능한 virtual 함수들이다. 간단하게 짚고 넘어가려한다.increaseAllowance (확장x)spender의 allowance값을 증가시킨다.decreaseAllowance (확장x)spender의 allowance값을 감소시킨다._mint토큰을 발행하고, 계정에 토큰을 할당한다._beforeTokenTransfer토큰 송금 실행 전에 실행되는 함수 (Openzepplin) 확장 함수에서만 사용됨_afterTokenTransfer토큰 송금 실행 후에 실행되는 함수 (Openzepplin) 확장 함수에서만 사용됨몇개의 함수가 조금 더 있지만 ERC-20 인터페이스에서 제공하는 함수와 기능을 조금 확장한 것이라 지금 설명한 함수들을 참고해 코드를 살펴보면 충분히 알 수 있는 정도의 확장이다.Contract 작성MyToken.sol// SPDX-License-Identifier: MITpragma solidity ^0.8.7;import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;contract MyToken is ERC20 { address public _adminAddress; constructor(string memory _name, string memory _symbol, uint _initSupply) ERC20(_name, _symbol){ _adminAddress = msg.sender; _mint(msg.sender, _initSupply * (10 ** uint256(decimals()))); }}소스를 살펴보면 굉장히 간단한 것을 볼 수 있다._adminAddress는 송금을 위한 관리자 지갑을 따로 변수로 저장하여 사용하며,_mint함수를 통해 토큰을 발행한 뒤 관리자 계정에 할당하였다.그리고 주요기능은 ERC20토큰을 이용해 사용할 것이며 추후에 Swap, Staking 등의 기능을 추가할 생각이다.자 이제 배포를 해보자!난 아래와 같이 생성자 파라미터를 구성했다. (개인 마음대로 변경해도 상관없다!)그런 뒤에 Transet 버튼을 누르면아래와 같이 배포 계약이 실행된다.그리고 배포 한 뒤에 아래의 토큰 가져오기를 클릭하고 배포한 Contract주소를 넣고 가져오기를 실행하면아까 배포시에 설정했던 이름의 토큰이 발행된걸 확인할 수 있다!또한, Deploy 후 Remix에서 파라미터를 넣어서 함수들을 테스트해볼 수 있다.EtherScan에 들어가 Contract에 대해 확인이 가능하다." }, { "title": "Npm Install Error Code 128 해결", "url": "/posts/post13/", "categories": "Web, Trouble Shooting", "tags": "React, Trouble Shooting, npm", "date": "2022-05-07 00:00:00 +0900", "snippet": "NPM - Install Error Code 128노트북으로 작업을 한 것을 푸쉬하고 데스크톱에서 pull을 받아 npm install을 실행했더니아래와 같은 오류 메세지가 떴다.구글링으로 찾아봤더니 npm 버전이 최신이 아니라 뜨는 거라고 나오더라 그래서 아래와 같이 실행하고 다시npm install을 실행하니 잘 됐다!npm install -g npm" }, { "title": "Recoil vs Redux", "url": "/posts/post12/", "categories": "Web, React", "tags": "React, Recoil, State, Redux", "date": "2022-05-03 00:00:00 +0900", "snippet": "Recoil vs ReduxReact는 보통 State 관리 도구로 Redux, MobX 등의 라이브러리를 사용했다. 근데 이번에 NextJs로 프로젝트를 시작하면서 상태관리를 어떤 라이브러리를 사용할까 하다가 페이스북에서 React.Js 전용 상태관리 라이브러리로 출시한 Recoil 선택하게 되었다!그래서 이번엔 Redux와 Recoil을 비교해가며 왜 Recoil을 선택 했는지 알아보자ReduxRedux 설명 사진FluxRedux는 Flux 디자인 패턴을 기반으로 제작되어있다.위와 같이 Dispatcher, Action, Store, View로 이루어져 있으며, 단방향 데이트 흐름을 가지고 있다. 모든 데이터는 디스패처를 통해 중앙 허브로 흐르며, View에서 상호작용이 일어나면 Action을 Dispatch을 통해 스토어로 전달하여 데이터를 변경하고, 상위 구성요소 트리에서 자신과 모든 하위 항목을 다시 렌더링하는 흐름이다.그렇다고 Redux == Flux는 아니다 가장 큰 차이점은 Flux는 여러 개의 Store를 가지고 있지만, Redux는 단일 스토어만을 가지고 있다. 그리고 Redux는 Reducer라는 순수 함수를 여러개 두어 state를 변경한다.Recoil먼저 Recoil을 처음 접하고 생각 든 것은 굉장히 코드가 간결하고 간단하다였다. Redux는 처음 싲가하려면 많은 보일러 플레이트과 코드를 작성해야하고, 비동기 데이터 처리나 캐시와 같은 기능은 redux-saga 따위를 사용하는 불편함이 있었다.Recoil은 이미 React에서 제공하는 Hook과 항상 유사한 형태이다. 그래서 많은 코드 양을 만들지 않고 사용할 수 있고, selector문을 통해서 비동기 데이터 흐름을 위한 솔루션도 제공한다.AtomRecoil의 가장 기본 단위이다. 컴포넌트에서 Import하여 사용할 State라고 생각하면 될 것 같다.atom 값을 변경하면 해당 값을 구독하고 있는 컴포넌트들이 모두 재렌더링 된다.export const titleState = atom&amp;lt;strring&amp;gt;({ key: &quot;title_State&quot;, default: &quot;제곧네&quot;,});useRecoilState, useRecoilValue, useSetRecoilState useRecoilState - atom 값을 굳고하여 업데이트할 수 있는 hook이며, useState와 동일하게 사용할 수 있다. useRecoilValue - atom 값만을 반환한다. useSetRecoilState - atom 값을 변경하는 setter 함수를 반환한다.import { useRecoilState } from &quot;recoil&quot;;import { titleState } from &quot;./atomfile&quot;const [title, setTitle] = useRecoilState&amp;lt;string&amp;gt;(titleState);const title = useRecoilValue&amp;lt;string&amp;gt;(titleState);const setTitle = useSetRecoilState&amp;lt;string&amp;gt;(titleState);Selectoratom에 의존하는 동적인 데이터 만들 수 있게 해준다. get 함수를 통해 반환하며, set 함수 또한 사용할 수 있다. selector에 영향을 주는 atom들의 값을 변경할 수도 있다는 것이다!const fontSizeState = atom&amp;lt;int&amp;gt;({ key: &quot;fontSizeState&quot;, default: 14,})const fontSizeLabelingState = selector({ key: &quot;fontSizeLabelingState&quot;, get: ({ get }) =&amp;gt; { const fontsize = get(fontSizeState); return `${fontsize}px`; }, });결론 Recoil이 Redux보다 사용하기 굉장히 간단하다. 순수 함수를 사용해 비동기 테이터를 쿼리할 수 있다. UseState와 동일하게 hook을 사용해 store를 컨트롤할 수 있다. Dispatcher 와 action 등의 코딩을 할 필요가 없기때문에 깔끔한 코드를 구성할 수 있다. 보일러 플레이트가 없다. Recoil은 아직 베터라 Redux는 확립되어 있기 때문에 안정성 면에선 Redux가 우위에 있다.내가 생각했을 때 지금 Recoil을 사용하지 않을 이유는 없다고 생각한다. 하지만, 대규모 프로젝트에선 안정성이 중요하기 때문에 위험을 감수하며 사용할진 잘 모르겠다." }, { "title": "Remix로 Solidity 로컬 개발 환경 만들기", "url": "/posts/post11/", "categories": "BlockChain, Ethereum", "tags": "BlockChain, Ethereum, Solidity, Remix", "date": "2022-05-02 00:00:00 +0900", "snippet": "Solidity로 개발을 하다보니 리믹스에서 git을 사용하기 좀 껄끄러운 것도 있고, github로 소스를 관리하다보니 테스트할 때마다 Remix에 매번 복붙해서 배포하는 것도 귀찮아 찾아보니 로컬로 Remix에 WebSoket과 연결해 동기화 해 개발하는 방식이 있더라!먼저, Solidity 파일이 있는 폴더로 이동해서npm으로 remix 설치npm install @remix-project/remixd그 후에 remix를 실행시켜주면 된다.remix startremixd -s . —remix-ide https://remix.ethereum.org성공했다면 아래 이미지와 같이 터미널에 나타난다.아래는 나타나는 웹 소켓에 대한 포트 설명이다. 65520 Port - Remix IDE와 파일 시스템 공유하며, Remix IDE에서 Localhost로 로드할 수 있다. 65523 Port - slither라는 Contract 세부 정보를 사용자에게 제공하여 경고를 보고 소스를 수정할 수 있게 해주는 플러그인을 활성화하는 포트이다. 그리고 Remix로 이동해서 workspace를 아래 사진과 같이 선택해주면요렇게 local에 있는 파일들이 Remix로 동기화 된다!그리고 Deploy 탭으로 가서 확인해보면 아래와 같이 100ether씩 들어간 account가 10개 있다 이 계정들로 deploy해서 테스트를 해볼 수 있다~" }, { "title": "NextJs styled-component 적용하기", "url": "/posts/post10/", "categories": "Web, NextJS", "tags": "Web, NextJS, React, TypeScript, styled-component", "date": "2022-05-01 00:00:00 +0900", "snippet": "Next 프로젝트를 Sass로 진행하다가 CSS-in-JS로 변경하려 한다. (클래스명 짓기가 너무 힘들다..ㅜㅜ) 또한, jsx에서 사용하는 js값을 css내에서 사용해서 유연하게 사용할 수 있더라… 그리고 클래스가 필요한 부분에선 NextJS에서 지원하는 css모듈 ([name].moudle.css)을 사용하여 해당 페이지에서만 사용할 생각이다.Next JS 에서 CSS-in-JS 적용하기styled-component이건 라이브러리라서 먼저 npm으로 다운 받아야한다. 나는 typescript를 사용하기 때문에 type을 붙였다.npm i type@styled-componentsSSR과 CSR의 생성 해시값이 일치하지 않아 오류가 뜨기 때문에 babel plugin을 다운받아서 세팅해준다.npm i babel-plugin-styled-components -D그리고 babel 세팅 파일을 만들어준다..babelrc{ &quot;presets&quot;: [ &quot;next/babel&quot; ], &quot;plugins&quot;: [ [ &quot;styled-components&quot;, { &quot;ssr&quot;: true, &quot;displayName&quot;: true, &quot;preprocess&quot;: false } ] ]}그리고 _document.tsx 파일을 생성해준다. 이 파일은 NextJS에서 head, body 부분을 Custom 할 수 있게 지원하는 파일이다.이 부분을 세팅하지 않으면 SSR렌더링 시에 styled가 주입되지 않아 꼭!! 해줘야한다.document.tsximport React, { ReactElement } from &quot;react&quot;;import Document, { Html, Head, Main, NextScript, DocumentInitialProps, DocumentContext } from &#39;next/document&#39;;import { ServerStyleSheet } from &quot;styled-components&quot;;// NEXT.JS CUSTOM DOCUMENT// https://nextjs.org/docs/advanced-features/custom-documentexport default class MyDocument extends Document { static async getInitialProps(ctx: DocumentContext): Promise&amp;lt;DocumentInitialProps&amp;gt; { const sheet = new ServerStyleSheet(); const originalRenderPage = ctx.renderPage; try { ctx.renderPage = () =&amp;gt; originalRenderPage({ enhanceApp: (App) =&amp;gt; (props) =&amp;gt; sheet.collectStyles(&amp;lt;App {...props} /&amp;gt;), }); const initialProps = await Document.getInitialProps(ctx); return { ...initialProps, styles: ( &amp;lt;&amp;gt; {initialProps.styles} {sheet.getStyleElement()} &amp;lt;/&amp;gt; ), }; } finally { sheet.seal(); } } render(): ReactElement { return( &amp;lt;Html lang=&quot;en&quot;&amp;gt; &amp;lt;Head&amp;gt; // 이곳엔 폰트 혹은 meta 태그를 넣을 수 있다. &amp;lt;/Head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;Main /&amp;gt; &amp;lt;NextScript /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/Html&amp;gt; ); }}자 다 됐다. 이제 화면에서 사용한다면 요렇게 Layout을 세팅하여 사용하면 된다~import styled from &quot;styled-components&quot;;const Layout = ({ children }: Props): JSX.Element =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Container&amp;gt; &amp;lt;NavBar /&amp;gt; &amp;lt;Content&amp;gt;{children}&amp;lt;/Content&amp;gt; &amp;lt;footer&amp;gt; &amp;lt;Footer /&amp;gt; &amp;lt;/footer&amp;gt; &amp;lt;/Container&amp;gt; &amp;lt;/&amp;gt; );};const Container = styled.div` display::flex; justify-contents:center; flex-direction:column; min-height:100vh;`;const Content = styled.div` display: flex; flex: 1;`;" }, { "title": "React TypeScript 프로퍼티로 SetState가지기", "url": "/posts/post9/", "categories": "Web, React", "tags": "Web, React, TypeScript", "date": "2022-04-29 00:00:00 +0900", "snippet": "개발하다보니 모달을 껐다 켰다하는 props를 부모에 callback함수를 호출해 제어하기 위해 SetState를 TypeScript Interface로 정의하고 싶은 경우가 생겼다.그런경우 아래와 같이 코드를 사용하면 된다.import { Dispatch, SetStateAciton } from &quot;react&quot;interFace IModal{ SetShow: Dispatch&amp;lt;SetStateAction&amp;lt;boolean&amp;gt;&amp;gt;;}const modal =({SetShow}:IModal): JSX.Element =&amp;gt; { const onCloseModal = useCallback((): void =&amp;gt; { SetShow(false); }); return( &amp;lt;div&amp;gt; modal &amp;lt;/div&amp;gt; &amp;lt;button onClick ={onCloseModal}&amp;gt; modal Close &amp;lt;/button&amp;gt; )}" }, { "title": "React Hooks", "url": "/posts/post8/", "categories": "Web, React", "tags": "Web, React", "date": "2022-04-28 00:00:00 +0900", "snippet": "React HooksReact 16.8 버전부터 추가된 개념이다. 함수형 프로그래밍을 위해 도입된 기능이며, 클래스를 사용하지 않고도 State를 이용하고 React의 기능들을 사용할 수 있다.Hooks Rules 최상위 코드레벨에서만 Hooks를 호출해야한다. 루프나 조건 혹은 함수 내에서 Hooks을 생성하면 안된다. React의 함수 Component에서만 Hooks을 사용해야 한다. 일반 JavaScript에서는 사용할 수 없다. useStateStateFul한 값과 이를 업데이트할 수 있는 함수를 반환한다.Exampleimport React, { useState } from &quot;react&quot;;const [state, stateChanged] = useState&amp;lt;string&amp;gt;(&#39;&#39;);// 이런식으로 state를 업데이트할 수 있다. 새 state 값은 Component의 ReRendering 목록에 쌓이게 된다.stateChanged(&#39;변경값&#39;);useEffectuseEffect는 React의 Component에서 DOM 변경, 데이터 변경 등의 이벤트가 일어날 때 발생되는 작업이다. useEffect 하나로 componentDidMount, componentDidUpdate 등의 React 클래스에서 제공한 라이프 사이클 같이 사용할 수 있다.하나의 컴포넌트에서 여러개의 useEffect를 사용할 수 있다.Exampleimport React, { useState , useEffect } from &quot;react&quot;;function EffectEx() { const [cnt, cntChanged] = useState(1); const [cnt2, cnt2Changed] = useState(1); // 두번째 인자를 무엇으로 넣는지에 따라 업데이트 기준을 잡을 수 있다. // cnt가 변경될 때만 실행 useEffect(() =&amp;gt; { console.log(cnt+1); }, cnt); // 컴포넌트가 처음 DOM에 올라갈 때 실행 useEffect(() =&amp;gt; { console.log(&#39;first Start&#39;); }, []); // cnt 또는 cnt2 가 변경될 때 실행 useEffect(() =&amp;gt; { console.log(`cnt2${cnt2}` ); }, [cnt, cnt2]); return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;Count: {cnt} &amp;lt;/p&amp;gt; &amp;lt;button onClick={() =&amp;gt; cntChanged(cnt+1)}&amp;gt;값 증가&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; )}useMemo메모리제이션 된 값을 반환하는 Hook이다. 쉽게 말해서 State를 메모리에 적재해 뒀다가 의존성 배열에 넘겨준 값이 변경되었을 때만 새로운 메모리제이션된 값을 반영한다.복잡한 코드가 매번 리렌더링 될때마다 실행되는 걸 제한하기 위한 최적화를 위한 Hook이다.import React, { useMemo } from &quot;react&quot;;const [stateVal, valChange] = useState(1)const [stateVal2, valChange2] = useState(1)const doubleValue = useMemo(() =&amp;gt; stateVal * 2, [stateVal]) useMemo로 생성하지 않으면 stateVal2가 바뀔때마다 doubleValue도 항상 새로 계산하게 된다.useMemo로 생성하면 두 번째 인자로 들어가는 stateVal이 변경될때만 doubleValue을 새로 계산한다.useCallback메모리제이션 된 함수를 반환하는 Hook이다. useMemo와의 차이는 반환 하는 것에 차이 그 뿐이다.import React, { useCallback } from &quot;react&quot;;const [stateVal, valChange] = useState(1)const [stateVal2, valChange2] = useState(2)const CallbackEx = useCallback(() =&amp;gt; MemoValue(stateVal), [stateVal])useCallback로 만들어 두지 않으면 stateVal, stateVal2 하나라도 값이 변경되면 리렌더링 되면서 CallbackEx 함수가 무조건 선언된다.위에처럼 useCallback로 선언하고 2번째 인자(여기서는 StateVal) 로 의존할 배열을 채워 놓으면 stateVal이 변경될때만 CallbackEx함수가 선언되게 된다." }, { "title": "NextJS", "url": "/posts/post7/", "categories": "Web, NextJS", "tags": "Web, React, NextJS, SSR, CSR", "date": "2022-04-27 00:00:00 +0900", "snippet": "NextJSReact로 웹 애플리케이션을 구성하기엔 고려할게 많이 있다.React 코드는 webpack과 같은 번들러를 사용하여 번들링되고 Babel과 같은 컴파일러를 사용하여 변환되어야 한다. 코드 분할과 같은 프로덕션 최적화를 수행해야 한다. 성능 및 SEO를 위해 일부 페이지를 정적으로 미리 렌더링 하는 것이 좋다. React 앱과 데이터베이스를 연결하기 위해 서버측 코드를 작성해야 한다. 물론 기술적으로 다 고려하고 개발할 수도 있는 것들이다. 하지만, 기술적으로 높은 수준을 요구하고, 시간 비용에서 비효율적이다. 그것을 NextJS를 통해 해결할 수 있다.아래는 NextJS가 위에 문제에 대해 제공하는 솔루션과 기본으로 제공하는 기능들이다.Page 기반으로 라우팅 시스템을 지원React를 쓰려면 필수적으로 react-router-dom을 통한 라우팅이 필수적이다.next 또한 react-router-dom을 dependency하여 개발하였지만 파일 이름을 기반으로&#39;js&#39;, &#39;jsx&#39;, &#39;ts&#39;, &#39;tsx&#39;, &#39;pages&#39; 라우팅 시스템을 제공한다예를 들어 pages/about.js 과 같은 React Component가 있다면 해당 주소를 넣으면 /about 주소를 넣으면 바로 Redirect 된다.Pre-rendering / SSG 및 SSR 지원Pre-Rendering기본적으로 NextJS는 모든 페이지를 미리 렌더링한다. 즉, 클라이언트 측에서 JavaScript로 모든 작업을 수행하는 대신 각 페이지에 대해 미리 HTML을 생성한다.사전 렌더링을 통해 더 나은 성능과 SEO를 확보할 수 있다.SSG (Static-Site-Generation)NextJS를 사용하면 각 페이지를 사용할 사전 렌더링 양식을 선택할 수 있다.대부분의 페이지에는 SSG를 사용하고 SSR이 필요한 페이지만 SSR로 구성하여 하이브리드 웹 앱을 만들 수 있다.SSG는 성능 향상은 위한 추가 구성이 없이 CDN에서 캐시할 수 있기 때문에 SSR에 비해 성능이 유리한 면이 있다.SSG는 사용자 요청에 앞서 페이지를 미리 렌더링할 필요가 없다면 좋은 생각은 아니다. 페이지가 변경되고, 사용자와 계속 상호작용 한다면 말이다.SSR (Server-Side-Rendering)이전에 포스팅한게 있으니 간단하게 넘어가겠다. SSR은 HTML 페이지는 서버에 요청에 따라 만들어진다.getSeverSideProps를 통해 해당 페이지의 데이터를 넘겨줄 수 있다.최적화된 프리페칭을 위한 Client-Side RoutingNextJs의 Router을 사용하면 SPA와 유사하게 페이지 간에 클라이언트 측 Routing을 수행할 수 있다.내장 CSS 및 Sass 지원 및 CSS-in-JS 라이브러리 지원전역으로 style 적용하기app.js 파일에 css을 적용하게 되면 모든 페이지와 구성 요소에 적용한다.코드는 아래와 같다.import &#39;../global.css&#39;function MyApp({ Component, pageProps }: AppProps) { return (&amp;lt;Component {...pageProps} /&amp;gt;)}node_moudles에서 css 가져오기bootstrap과 같은 전역 stylesheet를 가져오기 위해서는 위와 똑같이 사용하면된다.import &#39;bootstrap/dist/css/bootstrap.css&#39;function MyApp({ Component, pageProps }: AppProps) { return (&amp;lt;Component {...pageProps} /&amp;gt;)}다른 컴포넌트에서 다른 컴포넌트 CSS를 가져오고 싶으면import &#39;@reach/dialog/styles.css&#39;이런식으로 적용하면 된다.Component-Level css 추가NextJS는 파일 명명 규칙을 통해 CSS 모듈을 지원한다. [name].moudle.cssCSS 모듈은 고유한 클래스 이름을 자동으로 생성해 CSS 범위를 로컬로 지정한다. 이러면 충돌을 걱정하지 않고 다른 파일에서 동일한 CSS 클래스명을 사용할 수 있다.사용하는 방식은 아래와 같다.Button.module.scss.click{ color: red; background-color: blue;}component/button.jsimport styles from &#39;./Button.moudle.scss&#39;const button = () JSX.Element =&amp;gt; { return( &amp;lt;button className={styles.click}&amp;gt;&amp;lt;/button&amp;gt; )}SASS먼저 npm을 통해 sass를 설치해야 한다.npm install sass그리고 next.config.js파일에서 다음과 같이 Sass 컴파일러를 구성할 수 있다.const path = require(&#39;path&#39;)module.exports = { sassOptions: { includePaths: [path.join(__dirname, &#39;styles&#39;)], },}CSS-in-JS이름과 같이 Javascript 안에서 CSS를 사용할 수 있다.function CssInJs(){ return &amp;lt;p style=&amp;gt;안녕&amp;lt;/p&amp;gt;}Fast RefreshReact Component에 대한 편집 사항을 바로 화면에 반영하는 기능이다. 보통 1초 안에 실행된다.완전한 확장 가능Next의 기존 코드를 Extension하여 사용할 수 있다." }, { "title": "블록체인이란?", "url": "/posts/post6/", "categories": "BlockChain, 개념", "tags": "BlockChain, BitCoin, Ethereum, SmartContract", "date": "2022-04-23 00:00:00 +0900", "snippet": "시작전에..현재 굉장히 각광받고 있는 기술이며, 개발자과 관련 없는 사람도 한 번 쯤은 들어본지 꽤나 된 기술이다.인터넷에 떠다니는 많은 글 들을 읽어 봤지만 이해하기 힘든 경우도 많았고, 이번에 블록체인 관련 ‘Mastering’ 시리즈로 유명한 BitCoin Mastering이란 책을 읽으면서 어느정도 개념을 정리할 수 있을 것 같아서 이번 포스팅을 시작하게 되었다.블록체인이란?1982년 David Chaum의 논문 “Computer Systems Established, Maintained, and Trusted by Mutually Suspicious Groups”으로 처음 제안이 된 프로토콜이며, 1991년 Stuart Haber와 W.Scott Stornetta의 논문 “How to time-stamp a digital documen”의해 설명되었다.그 이후로 2008년 “Satoshi Nakamoto”의 비트코인에 의해 처음 대중적으로 알려지게 되었다. 블록체인은 거래가 담겨져 있는 블록이 이전 블록과 연결되어 있는 형태의 정돈된 목록이며, 각 블록은 블록의 헤더에 “SHA256” 암호화 해시 알고리즘을 이용하여 해시를 생성하며, 블록 헤더의 “이전 블록 해시”필드를 동해 “부모 블록”이라 할 수 있는 이전 블록을 참조한다. 각 블록에서 부모 블록을 연결해 주는 해시의 배열은 첫 생성 블록까지 이어지며 이것을 체인이라한다. “Satoshi Nakamoto”는 BitCoin 백서에서 해시와 체인을 구분하여 칭하였지만, 현 시대에선 블록체인이라고 통상 칭한다.블록체인 - 블록구조블록은 공개 장부인 블록체인에 거래들을 포함시키기 위해 한데 합쳐 놓은 컨테이너 데이터 구조이다.블록은 메타데이터를 담은 헤더와 그 뒤 블록 크기를 결정하는 거래목록이 길게 나열되어 있다.아래는 블록 구조이다.블록 구조 크기 필드명 설명 4바이트 블록 크기 블록의 크기 (단위: 바이트) 80바이트 블록 헤더 여러 필드가 블록헤더를 생성 1~9바이트 거래 카운터 거래 갯수 가변적 거래 블록에 기록된 거래 블록 헤더블록의 가장 중요한 정보들을 가지고 있는 부분이다.블록 헤더는 메타데이터의 3가지 집합으로 구성되어 있다.첫 번째로 이전 블록과 연결 값인 이전 블록의 해시값이 있다.두 번째 집합은 난이도, 타임스탬프, 난스(nonce) 이며 채굴 경쟁과 연관되어있다.세 번째 집합은 머클 트리 루트이다. (머클 트루는 너무 내용이 많아 추후 포스팅 예정) 간단히 짚고 넘어간다면, 블록 내의 거래를 효율적으로 요약하는 데이터 구조이다." }, { "title": "JavaScript 코드의 실행과정", "url": "/posts/post5/", "categories": "Web, JavaScript", "tags": "javascript, Execution Context, hoisting, scope, es6", "date": "2022-04-21 00:00:00 +0900", "snippet": "JavaScript의 실행과정 처음 브라우저에서 서버에서 클라이언트 코드를 요청하여 HTML 코드를 읽으며 &amp;lt;script&amp;gt; 태그를 이용한 JavaSript(편의상 JS) 코드와OnClick과 같은 JS 코드가 포함된 속성들을 브라우저의 JS 엔진으로 보낸다. JS는 스크립트를 실행하기 위해 실행 컨텍스트(Execution Context)를 생성한다. JS는 단일 스레드의 특성 상 Execution Stack을 쌓게 된다. GEC(Global Execution Context)가 가장 먼저 쌓이고 그 후로 FEC(Funtion Execution Context)들이 쌓이게 된다. Stack에 쌓인 실행 컨텍스트들이 실행 되고 Pop처리가 되고,실행된 컨텍스트는 JS엔진에서 활성 실행 컨텍스트가 된다.— Execution Context (EC)실행 과정들을 과정을 정확히 이해하기 위해서는 Execution Context에 대한 설명이 필요하다.EC는 scope, hoisting, this, closure 등의 동작 원리를 담고 있는 자바스크립트의 핵심 원리이다.Execution Context는 세 가지 종류가 있다. Global Execution Context Function Execution Context Eval Execution Context (하지만 보안 문제로 인해 eval 코드를 절대 사용하지 말 것으로 권고하며, 설명에서도 넘어가도록 한다.) Global Execution Context (GEC)3번 과정에서 Stack을 쌓게될 때 가장 먼저 GEC를 쌓게 된다. 모든 JS 파일은 하나의 GEC만이 존재할 수 있으며, 함수 내부에 없는 전역으로 사용할 수 있는 JS 코드가 실행되는 컨텍스트이다.Function Execution Context (FEC)함수가 호출될 때 마다 JS 엔진이 GEC 내에서 FEC를 생성한다. 함수마다 고유한 FEC를 만들게 되며, 여러개의 FEC가 존재할 수 있다.Execution Context의 생성 과정EC는 다음과 같은 과정으로 생성된다.생성 단계EC는 생성 단계를 거치며 Lexical Environment component와 VariableEnvrionment component를 생성하게 된다.Leximal Envrionment (LE)LE는 변수와 함수와 같은 실체 객체의 매핑을 보유하는 Component이다.예를 들어 아래와 같은 코드가 있다면var a = 20;var b = 40;function example(){ console.log(&#39;test&#39;);}LE는 아래와 같은 형태로 만들어진다.LE = { a: 20, b: 40, example: &amp;lt;ref, to example function&amp;gt;}또한, LE는 3가지의 구성요소를 가지고 있는데Environment Record변수 및 함수 선언이 LE 내부에 저장되는 곳이다.Declartive Environment Record (변수 및 함수 선언을 저장하는 레코드)Object Environment Record (브라우저의 창 객체를 저장하는 레코드)이렇게 두가지의 레코드 구조를 가지고 있다.Reference to the outer environment이름에서 말하 듯이 외부 환경에 대한 참조이며, 외부 환경 내부의 변수를 찾을 수 있게한다.This Binidng우리가 익히 알고있는 this 속성이다. GEC에선 이건 통상 (window)를 뜻한다. 아래는 GEC의 this 호출과 FEC의 this 호출의 차이다.const FEC = { m: 100, n: 50, calc: function() { console.log(this.m-this.n) }}FEC.calc(); // 50이 콘솔에 적히며, calc은 FEC 객체를 참조하기 때문에 this 함수로 FEC 내의 m과n을 참조하게 된다.const GEC = FEC.calc;GEC(); // NaN이 출력되며 여기서 calc에서 this는 전역으로 적힌 m과 n을 찾게 되는데 선언된 변수가 없기 때문에 NaN이 출력되게 된다.Variable Environment (VE)위에서 정의한 Leximal Environment에서 기술한 구성요소를 모두 가지고 있으며, LE와의 차이점은 LE는 함수 선언과 변수(let, Const) 바인딩을 저장하고, VE는 Var 형식의 바인딩만을 저장하는데 사용된다.실행 단계이 단계에서는 모든 변수에 대한 할당이 완료되고, 코드가 최종적으로 실행된다.아래와 같은 JS가 작성되었을 때 let a = 1; const b = 2; var c; function multiple(e,f){ var g = 20; return e * f * g; } c = multiply(20,30);GEC의 실행단계 까지 과정은 이렇다.생성 단계 GEC = { LexicalEnvrionment:{ EnvironmentRecord: { Type: &quot;Object&quot;, a: uninitalized, b: uninitalized multiply: &amp;lt;func&amp;gt; }, outer: null, ThisBinding: &amp;lt;Global Object&amp;gt; }, VariableEnvironment:{ EnvironmentRecord: { Type: &quot;Object&quot;, // Identifier bindings go here c: undefined, }, outer: &amp;lt;null&amp;gt;, ThisBinding: &amp;lt;Global Object&amp;gt; } }; 실행 단계GEC = { LexicalEnvironment: { EnvironmentRecord: { Type: &quot;Object&quot;, // Identifier bindings go here a: 20, b: 30, multiply: &amp;lt; func &amp;gt; } outer: &amp;lt;null&amp;gt;, ThisBinding: &amp;lt;Global Object&amp;gt; }, VariableEnvironment: { EnvironmentRecord: { Type: &quot;Object&quot;, // Identifier bindings go here c: undefined, } outer: &amp;lt;null&amp;gt;, ThisBinding: &amp;lt;Global Object&amp;gt; } }아래는 multiply 함수가 실행되며 만들어진 FEC의 실행과정이다.생성 과정FunctionExectionContext = { LexicalEnvironment: { EnvironmentRecord: { Type: &quot;Declarative&quot;, // Identifier bindings go here Arguments: {0: 20, 1: 30, length: 2}, }, outer: &amp;lt;GlobalLexicalEnvironment&amp;gt;, ThisBinding: &amp;lt;Global Object or undefined&amp;gt;, }, VariableEnvironment: { EnvironmentRecord: { Type: &quot;Declarative&quot;, // Identifier bindings go here g: undefined }, outer: &amp;lt;GlobalLexicalEnvironment&amp;gt;, ThisBinding: &amp;lt;Global Object or undefined&amp;gt; }}실행 과정FunctionExectionContext = { LexicalEnvironment: { EnvironmentRecord: { Type: &quot;Declarative&quot;, // Identifier bindings go here Arguments: {0: 20, 1: 30, length: 2}, }, outer: &amp;lt;GlobalLexicalEnvironment&amp;gt;, ThisBinding: &amp;lt;Global Object or undefined&amp;gt;, }, VariableEnvironment: { EnvironmentRecord: { Type: &quot;Declarative&quot;, // Identifier bindings go here g: 20 }, outer: &amp;lt;GlobalLexicalEnvironment&amp;gt;, ThisBinding: &amp;lt;Global Object or undefined&amp;gt; }}함수가 완료된 후의 반환 값은 내부에 저장되게 된다. 따라서 GEC가 업데이트 된다.끝 맺으며오늘은 Javascript의 내부적인 동작 과정에 대해 기술했다. 모든 개념을 알아둘 필요는 없을 것 같지만, 전체적인 개념을 충분히 이해하면 Closer, Hoisting(let,const 등장 이후로 쓸일은 없지만…), Scope 등의 개념을 이해하기 훨씬 수월할 것 같다." }, { "title": "데이터 바인딩 (Data Binding)", "url": "/posts/post4/", "categories": "CS, Web", "tags": "Binding, 바인딩, 데이터 바인딩, 단방향 바인딩, 양방향 바인딩", "date": "2022-04-18 00:00:00 +0900", "snippet": "데이터 바인딩(Data Binding)데이터 바인딩은 뷰 요소 혹은 사용자 인터페이스를 채우는 데이터를 연결하는 프로세스이다. 즉, Model과 View의 연결을 생성한다.쉽게 생각한다면, UI 구성요소에 데이터를 동기화 시키는 방법이라 생각하면 될거같다.데이터 바인딩은 2가지 유형으로 분류할 수 있는데 단방향 바인딩과 양방향 바인딩이 존재한다.단방향 바인딩 (One-Way Binding) 단방향 바인딩에서 데이터 흐름은 모델 -&amp;gt; 뷰 혹은 뷰 -&amp;gt; 모델 하나의 방향이다 모델 -&amp;gt; 뷰 형식의 단방향 바인딩에서 데이터가 변경되었을 경우에 바인딩 되어있는 구성요소의 값이 자동으로 업데이트되지만, 구성요소에서 값을 변경하여도 바인딩 된 데이터의 값이 변경되지 않는다. UI에서 변경 내용을 모니터할 필요가 없는 경우에 단방향 바인딩을 사용하면 불필요한 리소스 확보를 줄일 수 있다. 양방향 바인딩 (Two-Way Binding) 양방향 바인딩에서 데이터 흐름은 모델 &amp;lt;-&amp;gt; 뷰 양방향이다. View에 대한 모든 변경 사항은 Model로 전파되고, Model에 대한 모든 변경 사항 또한 View에 반영된다. 웹 프레임워크들의 바인딩웹 프레임워크 3대장의 바인딩은 어떨까?AngularAngualr는 단방향, 양방향 바인딩 모두를 지원한다.ReactReact는 단방향 데이터 바인딩을 지원하며 둘 중 하나 조건을 따를 수 있다. Componet to View: Component 데이터의 모든 변경사항은 View에 반영 됨 View to Component: View 데이터의 모든 변경사항은 Component에 반영 됨VueVue는 단방향, 양방향 바인딩 모두를 지원한다." }, { "title": "DOM (Document Object Model) 과 브라우저 렌더링", "url": "/posts/post3/", "categories": "CS, Web", "tags": "DOM, CSSOM, RenderTree, Browser", "date": "2022-04-18 00:00:00 +0900", "snippet": "DOM (Document Object Model)MDN에서의 정의는 DOM은 웹 문서용 프로그래밍 인터페이스이다.그리고 다음 문장이 DOM의 핵심이다.DOM은 문서의 구조화된 표현(structured representation)을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공한다.쉽게 말해서 우리가 아래 코드처럼 html에 있는 element 객체를 접근해 스타일을 변경하거나 내용을 변경할 수 있게 해주는 역할을 한다.document.querySelector(&quot;.css&quot;);위에 글을 읽으면 이런 생각이 든다 그럼 DOM = HTML인가?아니다! HTML은 단순히 텍스트로 구성되어 있고 DOM은 HTML 문서의 내용의 구조가 객체 모델로 변환되어 “노드 트리” 개체 구조로 표현된다.아래는 그 예시다.HTML&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;타이틀 내용&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;내용&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;내용&amp;lt;/h2&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;DOM(출처: 나)DOM과 HTMLDOM의 수정var newitem = document.createElement(&quot;div&quot;);document.body.appendChild(newitem);위 코드처럼 자바스크립트로 DOM의 새로운 노드를 추가할 수 있다.위 코드는 DOM을 업데이트하지만 HTML 문서의 내용을 변경하진 않는다.DOM은 렌더링 하지 않는다.브라우저 뷰 포트에 보이는 것은 렌더 트리이다.렌더 트리에선 오직 렌더링 되는 요소만 관련 있기 때문에 시각적으로 보이지 않는 요소는 제외된다.&amp;lt;div style=&quot;display:none&quot;&amp;gt;&amp;lt;/div&amp;gt;위와 같은 코드에서 DOM은 div 요소를 포함하지만, 렌더 트리에선 포함하지 않는다.브라우저 렌더링브라우저는 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시한다.브라우저가 서버로부터 페이지에 대한 자원을 받으면 화면을 그리기 전에 여러 단계를 거친다.1. DOM 트리 구축을 위한 HTML 파싱브라우저의 렌더링 엔진에서 HTML 문서를 파싱하고DOM 노드로 변환하고, CSS 파일과 함께 스타일 요소 또한 CSSOM으로 변환된다.CSSOM: DOM과 관련된 스타일의 객체 표현 이 또한 노드 형식임2. 렌더트리 생성DOM과 CSSOM의 조합이며, 페이지에 최종적으로 렌더링 될 내용을 나타내는 트리이다.4. javascript 실행 (HTML 중간에 스크립트가 있다면 HTML 파싱이 중단된다.)자바스크립트 파일들이 실행되며 만약 HTML을 파싱 중에 스크립트를 마주하게되면 스크립트를 실행 한 뒤 다시 파싱이 시작된다.위와 같은 요소들을 블록 리소스라고 하는데 블록 리소스는 브라우저 로딩 단계 중 페인트 과정을지연시킴으로 스크립트를 임포트하는 위치를 CSS는 &amp;lt;head&amp;gt; 태그 내에 js를 실행시키는 &amp;lt;script&amp;gt; 태그는 &amp;lt;body&amp;gt; 태그의 맨 하단에 위치시키는 것이 좋다.&amp;lt;head&amp;gt; &amp;lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; &amp;lt;script&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/head&amp;gt;3. 뷰포트 기반으로 렌더트리의 각 노드가 가지는 위치와 크기를 계산 (Layout/Reflow 단계)레아이아웃은 뷰포트의 크기를 걸정하는 것으로 표시 영역 크기는 Html의 Head 테그의 정의되는 meta 태그에 의해 결정된다.아래는 그 예이다.&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&amp;gt;4. 계산한 위치/크기를 기반으로 화면에 그림 (Paint 단계)마지막으로 렌더트리를 이용해 페이지의 UI를 그리게 된다." }, { "title": "WebPack 그리고 babel", "url": "/posts/post2/", "categories": "Web", "tags": "webpack, babel", "date": "2022-04-14 00:00:00 +0900", "snippet": "React로 개발을 하다보면, Webpack 그리고 babel이란 단어를 심심치 않게 접하게 된다. 오늘은 Webpack과 babel의 개념에 대해서 알아보려고 한다.웹팩 등장 전아래와 같이 script를 바디에서 호출하는 식으로 사용했다.이런 경우 문제점은 전역 스코프가 오염되어 예측할 수 없게 된다. &amp;lt;script type=&quot;module&quot; src=&quot;src/math.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;module&quot; src=&quot;src/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;모듈 스팩CommonJSCommonJS는 자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표로 export 키워드로 모듈을 만들고 require()함수로 불러 들이는 방식이다. NodeJs에서 이를 사용한다.math.js:exports function sum(a, b) {return a+b; }app.js:const sum = require(&#39;./math.js&#39;);sum(1, 2); //3AMD브라우저 처럼 비동기로 로딩되는 환경에서 모듈을 사용하는 목표이다.UMDAMD기반으로 CommonJS 방식까지 지원하는 통합 형태이며, React나 바벨 웹팩을 이용했다면 친숙할 수 있는 형태이다.math.js:export function sum(a, b) {return a+b; }app.js:import * as math from &#39;./math.js&#39;math.sum(1, 2); //3WebPackWebpack 공식 Document의 정의는 JavaScript 애플리케이션을 위한 정적 모듈 번들러 으로 표기되어 있다.여기서 말하는 정적 모듈 번들러가 뭘까?먼저 여기서 말하는 모듈은 우리가 npm, yarn등으로 생성하는 node_modules와 Javascript, 이미지, Css 등을 패키징하여 재사용 가능하게 만드는 코드 덩어리이다. 그리고 번들링은 저 모듈들을 하나의 파일로 묶게 되는 것이다.출처: https://webpack.js.org/webpack의 장점 성능 최적화이렇게 모듈을 번들링하여 묶어서 얻는 장점이 무엇일까? 우리가 웹 페이지를 요청할 때 html, css, js 파일 등의 여러가지 파일을 요청하게 된다 이러한 요청을 WebPack을 이용해 요청의 수를 획기적으로 줄일 수 있다! 그러면 자원이나 성능에서 이점을 가져갈 수 있게 된다. 브라우저의 모듈 지원위에 설명한 UMD이나 CommonJS를 지원하지 않는 브라우저도 있기 때문에 브라우저 무관하게 모듈을 사용할 때 웹팩을 이용해 사용할 수 있다. entry/output (엔트리/아웃풋)entry: 모듈의 시작점을 지정한다. (모든 의존성이 시작되는 부분)output: 번들링이 진행되고, 코드가 저장될 위치loader (로더)웹팩에선 모든 파일을 모듈로 바라본다. 자바스크립트 뿐만 아니라 스타일시트, 이미지, 폰트까지도 모두 import 구문을 사용해 자바스크립트 코드 안으로 가져올 수 있다.이것을 가능하게 해주는 것이 웹팩의 로더 이다. 로더는 타입 스크립트 같은 다른 언어를 자바스크립트 문법으로 변호나해 주거나 이미지를 data URL 형식의 문자열로 변환시킨다.자주 사용되는 로더 css-loader: css를 js로 변환하기 위한 로더 style-loader: js로 처리된 css코드를 html에 주입시키는 역할을 하는 로더 file-loader: 이미지 파일을 모듈 파일로 사용할 수 있게 하는 로더 url-loader: 이미지 파일을 dataUrl 형식으로 변환시키는 로더 plugin (플러그인)플러그인은 로더가 파일 단위로 처리하는 반면 플러그인은 번들링된 결과물을 처리한다.자주 사용되는 플러그인 BannerPlugin: 빌드 시간, 정보, 버전 등을 맨 상단에 배너 형식으로 넣기 위한 용도 DefinePlugin: 환경 의존적인 정보들을 관리하기 위한 플러그인 HtmlTemplatePlugin: HTML의 파일을 빌드에 포함시킬 때 사용하는 플러그인 clean-webpack-plugin: 빌드 시마다 기존의 output 폴더를 삭제하고 다시 생성해주는 플러그인 MiniCssExtractPlugin: 스타일 코드만 뽑아서 별도의 CSS 파일로 만들어 파일을 분리하게 할 수 있다. webpack 설정해보기webpack-cli install / startwebpack과 cli 명령어로 실행할 수 있게 해주는webpack-cli을 함께 설치해준다.npm install -D webpack webpack-cliwebpack을 실행하기 위해서는 필수적으로 3가지의 옵션을 설정해야한다. mode: “development”, “production”, “none” 세 가지가 있으며 실행하는 환경에 따라 지정해주면 된다. entry: 모듈의 시작점 output-path: 번들링 된 파일이 만들어지는 위치아래와 같이 실행하게되면 dist폴더에 main.js라는 번들링 된 파일이 생기게 된다.node_modules/.bin/webpack --mode development --entry ./src/app.js --output-path dist/main.js번들링한 파일을 html 파일에서 로드해서 사용하면 된다. (type 지정하지 않아도 됨)index.html:&amp;lt;body&amp;gt; &amp;lt;script src=&quot;dist/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;webpack.config.js매번 cli로 옵션을 설정하기 힘드니 webpack.config.js 파일을 생성 해 관리해주면 된다.먼저 아래와 같이 package.json 파일에 script를 만들어주고package.json: &quot;build&quot;: &quot;webpack&quot;웹팽 파일 설정은 아래와 같이 해준다.webpack.config.js:const path = require(&quot;path&quot;);module.exports = { mode: &quot;development&quot;, entry: { main: &quot;./src/app.js&quot;, }, output: { path: path.resolve(&quot;./dist&quot;), // 여러개의 entry를 지정했을 때 동적으로 이름을 할당 filename: &quot;[name].js&quot;, },};babelWebPack을 이용할 때 babel의 개념에 대해 알아 둘 필요가 있다.ES6 클래스와 IMPORT문은 모든 브라우저에서 적용되진 않는다. 모든 브라우저에서 코드를 읽을 수 있도록 하려면 ES6의 기능을 ES5코드로 변환시켜주는 트랜스 파일링(작성한 코드를 다른 언어로 변환)이 필요하다.바벨은 세 단계로 빌드를 진행한다. Parsing - 코드를 토큰으로 하나씩 분해하여 추상 구문 트리(AST)로 변환한다.. Transforming - ES6 -&amp;gt; ES5로 변환 Printing - 변경된 결과를 결과 출력그리고 바벨은 보통 두 가지로 설정을 하게되는데 plugin과 preset이다.plugins플러그인을 코드를 ES6을 ES5로 변경해주는 코드인데 예를들어아래와 같이 ES5에서 지원하지 않는 arrow function을 ES5로 바꾸기 위해 @babel/plugin-transform-arrow-functions 플러그인을 설치해 설정파일에 넣어주면 된다.// ES6const sum = (a, b) =&amp;gt; { return a + b;};// ES5var sum = function (a, b) { return a + b;};preset위에서처럼 플러그인을 하나 하나 넣기에는 무리가 있기 때문에 플러그인을 모아서 사용하는 경우가 바로 preset이다.polyfill지원하지 않은 웹 브라우저 상의 기능을 구현하는 코드(ES6 - Map, Promise 등)을 사용가능하게 구현이 누락된 새로운 기능을 메꿔주는 역할쉽게말해서 ES6 에서 ES5로 변환되지 않는 것들을 추가적인 코드조각을 추가해서 해결하는 것이다.대표적인 env preset에선 아래와 같이 설정할 수 있다.corejs라는 polyfill을 사용한 것이다.babel.config.js:module.exports = { presets: [ [ &quot;@babel/preset-env&quot;, { targets: { chrome: &quot;79&quot;, ie: &quot;11&quot;, }, useBuiltIns: &quot;usage&quot;, corejs: { version: 2, }, }, ], ],};WebPack 과 babelWebPack이 모듈을 번들링할 때 Babel을 사용하여 트랜스 파일링 시킬 수 있다.웹펙에선 babel을 loader로 사용된다. 바벨 로더 / core-js 설치npm i babel-loader core-js@2 웹펙 파일 설정사용법은 굉장히 간단한데 설치한 로더를 다른 로더 사용하듯이 추가해주면 된다.exclude는 자바스크립트가 불러오는 node_module 내에 모듈까지도 바벨이 적용되지 않도록 방지하는 것이다.webpack.config.js:module.exports = { mode: &quot;development&quot;, entry: { main: &quot;./app.js&quot;, }, output: { path: path.resolve(&quot;./dist&quot;), filename: &quot;[name].js&quot;, }, module: { rules: [ { test: /\\.js$/, loader: &quot;babel-loader&quot;, exclude: /node_modules/, }, ], },};" }, { "title": "SSR와 CSR에 대해", "url": "/posts/post1/", "categories": "Web", "tags": "ssr, csr", "date": "2022-04-13 00:00:00 +0900", "snippet": "SSR (Server Side Rendering)SSR은 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.쉽게 말해서 서버에서 렌더링할 준비가 다 되면 HTML을 브라우저에게 응답해준다.출처: https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8CSR (Client Side Rednering)CSR은 JavaScript가 다운로드 및 실행될 때까지 기다릴 필요 없이 브라우저가 서버에서 HTML 렌더링을 시작한다.출처: https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8SSR vs CSR SSR의 경우는 서버에서 페이지를 모두 구성하여 사용자에게 보여주기 때문에 초기 페이지 구성이 느리지만 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다. CSR의 경우엔 클라이언트에서 페이지를 렌더링하기 때문에 빠른 속도로 초기 페이지를 볼 수 있지만 실제로 (React, Vue) 등이 실행이 완료되기 전까지 페이지와 상호작용할 수 없고, 서비스에 필요한 데이터를 클라이언트(브라우저)에서 추가로 요청하여 재구성해야 하기 때문에 전체적인 페이지 완료 시점은 SSR보다 느려진다. CPU의 처리량은 SSR이 CSR처리량보다 훨씬 적다. SSR을 사용하면 전체 페에지가 올바른 메타데이터로 컴파일 되어 프론트 엔드로 전송된다.하지만, CSR를 사용하면 사이트의 콘텐츠가 JS를 통해 자동으로 생성된다.어떤 페이지에서 다른 페이지로 이동할 때 메타데이터를 변경하는 것이 JS 실행에 의존하기 때문에 각 페이지에 대한 메타데이터를 설정하여 클라이언트에서 렌더링 되도록 해야 한다.즉, SSR 방식이 CSR보다 SEO 이용이 수월하다. 어떤거로 개발해야 할까?위에 글을 읽고 CSR와 SSR에 대해 알았다면 드는 생각은 하나다.&quot;CSR의 빠른 초기 페이지 로드와 SSR 성능을 조합해서 쓰는 방법이 없을까?&quot;방법이 존재한다. Next.js라는 웹 프레임워크를 사용하는 것.해당 프레임워크는 Pre-rendering HTML 방식을 이용하며 SSR과 CSR 방식을 혼합하여 사용하고 있다." } ]
